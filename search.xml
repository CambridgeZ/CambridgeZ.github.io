<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown入门</title>
    <url>/2022/08/15/Markdown%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Markdown入门"><a href="#Markdown入门" class="headerlink" title="Markdown入门"></a>Markdown入门</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
  cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;
&#125;
</code></pre>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><table>
<thead>
<tr>
<th align="center">你好</th>
<th align="right">你好</th>
<th align="left">你好</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有点意思</td>
<td align="right">有点意思</td>
<td align="left">有点意思</td>
</tr>
<tr>
<td align="center">什么</td>
<td align="right">好家伙</td>
<td align="left">好吧</td>
</tr>
<tr>
<td align="center">冲冲冲</td>
<td align="right">我爱C++</td>
<td align="left">什么东西</td>
</tr>
</tbody></table>
<p><strong>粗体</strong></p>
<p><em>倾斜</em></p>
<p><em><strong>斜体加粗</strong></em><br><del>删除线</del></p>
<p>&#x3D;&#x3D;高亮&#x3D;&#x3D;</p>
<p>我是^上标^</p>
<p>我是<del>小标</del></p>
<p>&#x3D;&#x3D;列表&#x3D;&#x3D;</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>一二三四五<ul>
<li>有点意思</li>
<li>呵呵哒<ul>
<li>你好哇</li>
</ul>
</li>
</ul>
</li>
<li>上山打老虎</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>&#x3D;&#x3D;引用&#x3D;&#x3D;</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<blockquote>
<blockquote>
<p>一二三四五</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一二三四五</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>分割线</p>
<p>&#x3D;&#x3D;LateX语法&#x3D;&#x3D;<br>$$<br>y&#x3D;x^2+2<br>$$</p>
<p>$$<br>\lfloor x\rfloor<br>\lceil y \rceil<br>\uparrow<br>\downarrow<br>\updownarrow<br>\backslash<br>\ulcorner<br>\llcorner<br>\urcorner<br>\lrcorner<br>|<br>\mathscr{ABCD 1234}<br>\mathfrak{ABCD 1234}<br>\mathbb{ABCDabcdefg 12345}<br>$$</p>
<p>$$<br>希腊字母<br>\alpha<br>\beta<br>\gamma<br>\epsilon<br>\zeta<br>A<br>\Delta<br>\delta<br>\Xi<br>\Lambda<br>\lambda<br>\sigma<br>\Sigma<br>\upsilon<br>\phi<br>\chi<br>\Phi<br>\varPsi<br>\pi<br>\rho<br>$$</p>
<p>$$<br>运算符\pm<br>\cdot<br>\cup<br>\oplus<br>\odot<br>\mp<br>\star<br>\times<br>\otimes<br>\setminus<br>\div<br>$$</p>
<p>$$<br>E&#x3D;m\cdot<br>c^2<br>$$</p>
<p>$$<br>二元关系符号:&lt; \ll \prec \sim \subset \in \parallel \asymp \gg \neq \approx\propto \notin \equiv \supset \ni \perp \leq \ge \subseteq \ni \simeq \cong<br>$$</p>
<p>$$<br>二元关系： \because  \subsetneqq \therefore\supsetneqq \ngtr \nless<br>$$</p>
<p>$$<br>\leftarrow   \rightarrow \leftrightarrow \nearrow \swarrow \Leftarrow \Rightarrow\longleftarrow<br>\Longleftarrow \Longleftrightarrow \circlearrowleft \nLeftarrow \nRightarrow \nleftarrow<br>\nrightarrow \leftrightarrows<br>$$<br>$$<br>其他符号：\forall \exist \nabla \ell \jmath \dots \cdots \vdots \ddots \aleph \S  \P<br>\angle  \infty<br>\heartsuit \hbar \hslash \bigstar \square \varnothing \measuredangle<br>$$</p>
<p>$$<br>\sin<br>\cos<br>\arccos<br>\arcsin<br>\arctan<br>\tan<br>\cot<br>\arctan<br>\cot<br>\sec<br>\cosh<br>\sinh<br>\min<br>\max<br>a^3_{ij}<br>{a_{ij}}^3<br>{}^{12}_{6}\mathrm{C}<br>$$</p>
<p>$$<br>微积分符号:\dot{x}&#x3D;v<br>$$</p>
<p>$$<br>\ddot{x}&#x3D;\dot{v}<br>$$</p>
<p>$$<br>y’&#x3D;x \qquad \int ^{death}_{birth}time &#x3D;life\qquad \iint_sE\cdot ds&#x3D;Q\cdot \epsilon_0\qquad 分式\frac{y}{x}\qquad \tfrac{a}{b}\qquad<br>$$</p>
<p>$$<br>\sqrt{2}\qquad\sqrt[3]{x}\qquad \overline{m+n} \qquad \underbrace{a_1+a_2+\ldots+a_n}_{n}<br>\qquad \underbracket[0.4pt][1ex]{a_1+a_2+\cdots+a_n}_n\quad a\xleftarrow{x+y+z} b<br>\qquad a\xrightarrow[x&lt;y]{a<em>b</em>c}d\qquad \hat A \qquad \hat{AB}\qquad<br>$$</p>
<p>$$<br>\qquad \tilde{C} \quad \widetilde{CD}\qquad A\overset{abc}{&#x3D;}B \qquad A\underset{b}{&#x3D;}C\quad 去心邻域\mathring{U}\qquad \sum_{i&#x3D;1}^n\qquad \prod_{j&#x3D;1}^{n}\qquad \sideset{_a^b}{_c^d}\sum<br>$$</p>
<p>$$<br>\sum_{\substack{0&lt;i&lt;n\0&lt;j&lt;m}}p_{ij}&#x3D;\prod_{\substack{i\in n\1&lt;j&lt;m}}q_{ij}\qquad \max\limits_{i&gt;1}^{x}\quad \mathop{xyz}\limits_{x&gt;0}<br>$$</p>
<p>$$<br>关于矩阵：\begin{pmatrix}0&amp;1\1&amp;0\end{pmatrix}<br>$$</p>
<p>$$<br>y&#x3D;\begin{cases}\int x,&amp;x&gt;0 \ 0, &amp;x&#x3D;0\ x-1 ,&amp;x&lt;0 \end{cases},x\in\mathbb{R}<br>$$</p>
<hr>
<h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>![理论](&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;截屏2021-01-30 16.35.22.png)</p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>[github](https:<a href="http://www.github.com/">www.github.com</a></p>
<pre><code class="mermaid">graph TD;
A--&gt;B;
B--&gt;C;
C--&gt;A;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL入门</title>
    <url>/2022/08/13/SQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="写在开头的几点事情"><a href="#写在开头的几点事情" class="headerlink" title="写在开头的几点事情"></a>写在开头的几点事情</h2><ol>
<li>mysql中的关键字不区分大小写也就是说 SELECT,select ,Select都是一样的管用</li>
<li>对于我们自己定义的属性的名称，虽然我们可以直接写写属性的名称，但是为了避免和关键走出现冲突常常使用”&#96;&#96;“将我们自定义的词语包括在其中</li>
<li>mysql中的注释语句目前我知道的有三种写法</li>
</ol>
<h2 id="数据基本操作"><a href="#数据基本操作" class="headerlink" title="数据基本操作"></a>数据基本操作</h2><pre><code class="mysql">CREATE DATABASE `learn_sql`; -- 创建数据库
SHOW DATABASES; -- 显示现在所有的数据库
USE `learn_sql`;  -- 开始使用某个数据库
</code></pre>
<h2 id="创建表格并操作"><a href="#创建表格并操作" class="headerlink" title="创建表格并操作"></a>创建表格并操作</h2><pre><code class="mysql">CREATE TABLE `student`(
    `student_id` INT PRIMARY KEY,-- 数据名称 数据类型，有一个数据为主键(primary key)
    `name` VARCHAR(20),  -- 字符串数据类型，VERCHAR(字符串长度)
    `major` VARCHAR(20) DEFAULT &#39;计算机&#39; -- 可以给某个数据类型默认值，这里默认的专业为计算机
);

DESCRIBE `student`;-- 显示表格里面各项数据及其类型
DROP TABLE `student`;-- 删除表格

ALTER TABLE `student` ADD gpa DECIMAL(3,2);-- 对于表格加入属性
</code></pre>
<h2 id="对于表格中的数据进行操作"><a href="#对于表格中的数据进行操作" class="headerlink" title="对于表格中的数据进行操作"></a>对于表格中的数据进行操作</h2><pre><code class="mysql">INSERT INTO `student` VALUES (2,&#39;小黑&#39;,&#39;生物&#39;,&#39;4.0&#39;);-- 插入数据
INSERT INTO `student` VALUES (3,&#39;小绿&#39;,NULL,NULL);-- 有的项目不想填的话直接写成null

INSERT INTO `student`(`name`,`major`,`studnet_id`,`gpa`) VALUES (&#39;小红&#39;,NULL,4,NULL);-- 可以在前面写东西来限制加入的属性的顺序

SELECT * FROM `student`; -- 用来查看表格中的所有数据。*在数据库中表示的是全部的意思
</code></pre>
<h2 id="在对于数据库中的数据做限制"><a href="#在对于数据库中的数据做限制" class="headerlink" title="在对于数据库中的数据做限制"></a>在对于数据库中的数据做限制</h2><pre><code class="mysql">--  constrain 限制
DROP Table `student`;
-- 在创建数据库时对于数据类型进行限制
CREATE TABLE `student`(
    `student_id` INT PRIMARY KEY,
    `name` VARCHAR(20) NOT NULL,-- 非空
    `major` VARCHAR(20) UNIQUE -- 不能重复
);
</code></pre>
<h2 id="对于数据库中进行增删改查"><a href="#对于数据库中进行增删改查" class="headerlink" title="对于数据库中进行增删改查"></a>对于数据库中进行增删改查</h2><pre><code class="mysql">INSERT INTO `student` VALUES (2,&#39;小黑&#39;,&#39;生物&#39;);-- 插入数据
INSERT INTO `student` VALUES (3,&#39;小绿&#39;,NULL);

DROP Table `student`;-- 删除表格

CREATE TABLE `student`(
    `student_id` INT AUTO_INCREMENT ,
    `name` VARCHAR(20) ,     
    `major` VARCHAR(20),
    PRIMARY KEY(`student_id`)
);

INSERT INTO `student` VALUES (1,&#39;小黑&#39;,&#39;生物&#39;);
INSERT INTO `student` VALUES (2,&#39;小绿&#39;,NULL);
INSERT INTO `student`(`name`,`major`) VALUES (&#39;小黄&#39;,&#39;计算机&#39;);

SELECT * FROM `student`;

-- 修改删除数据

SET SQL_SAFE_UPDATES=0;

CREATE TABLE `student`(
    `student_id` INT AUTO_INCREMENT ,
    `name` VARCHAR(20) ,     
    `major` VARCHAR(20),
    PRIMARY KEY(`student_id`),
    `score` INT
);

INSERT INTO `student` VALUES (1,&#39;小黑&#39;,&#39;生物&#39;,90);
INSERT INTO `student` VALUES (2,&#39;小绿&#39;,&#39;生物&#39;,70);
INSERT INTO `student`(`name`,`major`,`score`) VALUES (&#39;小黄&#39;,&#39;计算机&#39;,91);

SELECT * FROM `student`;

-- 修改
UPDATE `student` 
SET `major`= &#39;生命科学&#39;
WHERE `major`=&#39;生物&#39;;

-- 删除
DELETE FROM `student`
WHERE `score`&lt;80;

SELECT * FROM `student`;

-- 查询数据

SELECT `name`,`major` FROM`student`;
#查询时从低到高排序
SELECT * 
FROM `student`
ORDER BY `score` ;

#查询时从高到低排序
SELECT * 
FROM `student`
ORDER BY `score`,`student_id` DESC
LIMIT 1;

SELECT `name`,`major` FROM`student` limit 1;

SELECT *
FROM `student`
WHERE `major`=&#39;计算机&#39;;

SELECT *
FROM `student`
WHERE `major`IN(&#39;计算机&#39;,&#39;历史&#39;,&#39;生命科学&#39;);
</code></pre>
<h2 id="创建一个含有多个表格的复杂数据库"><a href="#创建一个含有多个表格的复杂数据库" class="headerlink" title="创建一个含有多个表格的复杂数据库"></a>创建一个含有多个表格的复杂数据库</h2><pre><code class="mysql">-- 创建比较复杂的数据库（创建一个简单的公司资料库）
DROP TABLE `student`;

CREATE table`employee`(
    `emp_id` INT PRIMARY KEY,
    `name` VARCHAR(20),
    `birth_date` DATE,
    `sex` varchar(20),
    `salary` int,
    `branch_id` int,
    `sup_id` int
);

create table `branch`(
    `branch_id` int primary key,
    `branch_name` varchar(20),
    `manager_id` int,
    foreign key(`manager_id`) references `employee`(`emp_id`) on delete set null
);

create table `client`(
    `client_id` int primary key,
    `client_name` varchar(20),
    `phone` varchar(20)
);

create table `work_with`(
    `emp_id` int,
    `client_id` int ,
    `total_sales` int,
    foreign key (`emp_id`) references `employee`(`emp_id`) on delete cascade,
    foreign key (`client_id`) references `client`(`client_id`) on delete cascade
);


#补上由于之前表格没有创建完而缺少的foreign key
alter table `employee`
add foreign key(`branch_id`)
references `branch`(`branch_id`) on delete set null;

alter table `employee`
add foreign key(`sup_id`) references `employee`(`emp_id`) on delete set null;

#插入数据
##所有有foreign key指向的那个东西必须先存在
# 这里我们选择先创建部门，然后把部门经理全部设置为null然后在后面创建员工表格的时候再把这个改回来
insert into `branch` values(1,&#39;行政&#39;,null);
insert into `branch` values(2,&#39;研发&#39;,null);
insert into `branch` values(3,&#39;资讯&#39;,null);

insert into `employee` values(206,&#39;小黄&#39;,&#39;1998-10-08&#39;,&#39;F&#39;,5000,1,null);
insert into `employee` values(207,&#39;小绿&#39;,&#39;1985-09-16&#39;,&#39;M&#39;,2900,2,206);
insert into `employee` values(208,&#39;小黑&#39;,&#39;2000-12-19&#39;,&#39;M&#39;,3500,3,206);
insert into `employee` values(209,&#39;小白&#39;,&#39;1997-01-22&#39;,&#39;F&#39;,3900,3,207);
insert into `employee` values(210,&#39;小蓝&#39;,&#39;1925-11-10&#39;,&#39;F&#39;,8400,1,207);

update `branch` set `manager_id`=208 where `branch_id`=3;
insert into `client` values(400,&#39;阿猫&#39;,&#39;13987655908&#39;);
insert into `client` values(401,&#39;阿狗&#39;,&#39;13987655912&#39;);
insert into `client` values(402,&#39;旺来&#39;,&#39;15487655908&#39;);
insert into `client` values(403,&#39;露西&#39;,&#39;18887655908&#39;);
insert into `client` values(404,&#39;艾萨克&#39;,&#39;1987655908&#39;); 

insert into `work_with` values(206,400,70000);
insert into `work_with` values(207,401,2400);
insert into `work_with` values(208,402,9800);
insert into `work_with` values(208,403,24000);
insert into `work_with` values(210,404,87940);

select * from  `branch`;
select * from `employee`;
update `branch` set `manager_id`=206 where `branch_id`=1;
update `branch` set `manager_id`=207 where `branch_id`=2;


-- 数据库操作练习
-- 1.获得员工的数据
select * from `employee`;
-- 2.获得客户资料
select * from `client` ;
-- 3.按照薪水对于员工进行排序
select * from `employee` order by `salary` desc;
select * from `employee` order by `salary` ;
-- 4.获得工资前三高的员工
select * from `employee` order by `salary` desc limit 3;
-- 5.获取所有员工的名字
select `name` from `employee`;
-- 6.不重复的获得性别
select distinct `sex` from `employee`;



-- aggregate function 聚合函数
-- 1.取得员工人数
select count(*) from `employee`;
select count(`sup_id`) from `employee`;
-- 2.取得出生在特定日期之后的女性员工人数
select count(*) from `employee` where `birth_date`&gt;&#39;1970_01_01&#39; and `sex`=&#39;M&#39;;
-- 3.取得所有员工的平均薪水
select avg(salary) from employee;
-- 4.取得所有员工薪水的总和
select sum(`salary`) from `employee`;
-- 5.找出薪水最高/低的员工
select max(`salary`) from `employee`;
select min(`salary`) from `employee`;


-- wildcards 万用字元。%代表多个字元。 _代表一个字元
-- 1.取得电话尾号为335的用户
select * from `client` where `phone` like &#39;%335&#39;;
-- 2.去的姓氏为‘阿’的客户
select * from `client` where `client_name` like &#39;阿%&#39;;
-- 3.生日在12月的员工
select * from `employee` where `birth_date` like &#39;%12%&#39;;
select * from `employee` where `birth_date` like &#39;_____12%&#39;;



-- union 联集
-- 1.员工的名字union客户的名字
select `name` from employee
union
select `client_name` from `client`;
-- 2.员工ID+员工名字 union 客户ID+客户名字
select `emp_id`as `total_id`,`name` as `total_name` from `employee` union select `client_id`,`client_name`from `client`; 
-- 合并数据类型要一样，数据数目要一样



-- join 连接
insert `branch` values(4,&#39;偷懒&#39;,null);
-- 取的所有部门经理的名字
select * from employee  join branch on emp_id= manager_id;
select `emp_id`,`name`,`branch_name` from employee  join branch on `employee`.`emp_id` = `branch`.`manager_id`;
select `emp_id`,`name`,`branch_name` from employee  left join branch on `employee`.`emp_id` = `branch`.`manager_id`; #只要左边的表格成立就可以回传资料



-- subquery子查询

-- 1.找出研发部门经理的名字
select `name` from employee where emp_id=(
    select `manager_id` 
    from `branch`
    where `branch_name` =&#39;研发&#39;
);
-- 2.找出对于一位客户销售额超过5000的员工的名字
select `name` from employee where emp_id in(
    select `emp_id` 
    from `work_with`
    where `total_sales` &gt; 50000
);
</code></pre>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我们应该面向谁歌唱</title>
    <url>/2024/01/22/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E9%9D%A2%E5%90%91%E8%B0%81%E6%AD%8C%E5%94%B1/</url>
    <content><![CDATA[<h2 style="text-align = right ">——腰乐队</h2>
![相见恨晚](/image/相见恨晚.jpeg)

]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>摇滚</tag>
      </tags>
  </entry>
  <entry>
    <title>关于南京我想的全是你</title>
    <url>/2024/06/29/%E5%85%B3%E4%BA%8E%E5%8D%97%E4%BA%AC%E6%88%91%E6%83%B3%E7%9A%84%E5%85%A8%E6%98%AF%E4%BD%A0/</url>
    <content><![CDATA[<p>我曾听说过一个说法，说一个人14岁时听的音乐风格很大程度上决定了一个人后半生会会喜欢什么样的音乐。回想一下我的十四岁，似乎很幸运，那个时候我父母还没在电子产品的管束上对我放松分毫，所以14岁的我基本不听音乐，如果那个时候我也能每天揣着mp3很难想象我是不是至今依然陶醉于如小苹果之类的神曲之中。本来我就觉得我是个彻彻底底的屌丝，或者用我的某位朋友常用来形容他自己的那个词，“国男”，没错，似乎用来形容我更合适一点，毕竟我还是很有自知之明的觉得他其实比我小帅一点，如果我今日依然每天哼着“热爱一百零五度的你”，我觉得即使不用在自己的履历上加上某所大学的名字我便已经足够诠释“没有性张力”到底是什么。</p>
<p>还好还好，还好因为我14岁乃至18岁前在音乐方面的匮乏，让我在上了大学开始每天戴着耳机独来独往时我可以欣赏不同的音乐风格，虽然口水歌也不是没听过，但是总归还是能找到了条螺旋曲折且通往所谓的高雅的道路，导致我偶尔也会有突然的自信，是否我整天“仰天大笑出门去，我辈岂是蓬蒿人”的同时我还能标榜一下自己其实还是有一点，哪怕真的只是一点所谓的文青气质，没准还能吸引到谁？</p>
<p>于是我在大一的时候沉溺于流行乐，或者准确的说主要是沉溺于周杰伦，我觉得这除了和我高中时身边杰伦的铁粉扎堆之外还有一层原因是我大学宿舍的柜子上贴了张他的卡片，那断然不可能是我贴的，大概是四年前或者久远一点，八年前睡在那张我睡了四年的小床上的人贴上去的，可能是被夺舍了，但我觉得更可能是那段时间真的是被某个人灵魂附体，我那段时间发自内心的觉得杰伦就是最牛逼的。我听了他的每一张专辑、每一首歌，《稻香》在那一年被我循环了二百多遍，有很长一段时间，当我坐到图书馆的桌子前却没办法平心静气看书的时候，一首稻香总是能带我回到最初的美好，让我悸动的心慢慢平静。</p>
<p>我想我可能会一直做杰伦的铁粉，如果不是我在大二开学不久听到了罗大佑的《恋曲1980》，“你曾经对我说，你永远爱着我，爱情这东西我明白但永远是什么？”、“今天你欢乐将是明天将是明天永恒的回忆”，这包含对于爱情的思考的歌词和某些旋律动听的情歌相比之下，我承认我移情别恋了，我开始喜欢上这位华语乐坛教父级的人物。除了那些深刻而不失优美的情歌，我觉得罗大佑让我想起了高中时学到过的四个字——“文以载道”，同样，歌曲不应该只是用来寄托自己的儿女情长，不应该只是来写男女之事，不应该只是用来歌颂，不应该只是用来赞美，还能用来思考社会的发展，“台北不是我的家，我的家乡没有霓虹灯”；还能用来讽刺，“大厦关了一些样品屋，屋子加上铁窗防老鼠”；还能用来表达对和平的向往，“抬头寻找天空翅膀，候鸟出现他的影迹，带来远处的饥荒无情的战火依然存在的消息”，更不用提他那几首薛定谔的存在的，饱含了对时代变革思考的歌曲。如果说杰伦的歌激励我按下单曲循环的是他天才般的旋律创作，那么罗大佑的歌则更多是因为他的歌词。也因此，我开始真正的接触到了民谣和摇滚。</p>
<p>正如我一直坚信的，这个世界总是会让相似的灵魂相遇，无论以什么方式。具体的时间我可能已经模糊，但是我永远记得那是特殊时期被迫在宿舍足不出户的时光里，B站某段作为视频Bgm的轻音乐像闪电一样击中了我，弹幕上飘过“你离开了南京，从此没人和我说话”。那天晚上，我认识了那个叫陈小二的虚拟人物，尽管是个虚拟人物，但陈小二先生仿佛遥远星球上一个优秀百倍的我。无论是他拧巴的行事准则，又或者是作为一个理想主义者对于自己价值准则的的坚守，还有他对待生活和事情的认真，让我景仰，更是深刻的影响了我余下的大学生涯。30年前，陈小二先生因为罗大佑的歌曲抱起了吉他，30年后，因为他那些粗糙的歌谣，五音不全、对乐器一窍不通的我也第一次动了学一学乐器的心思，买了一把廉价的烧火棍，这样在未来的某个日子里，至少在我自怜自艾的时候我还能为自己再唱起那些歌曲，问一问理想究竟多少钱一斤，想一想这个世界是否会好。在刚刚过去的那个冬天，我也将要离开南京，我又去了热河路，冬天总是天黑的很早，五点多便已是华灯初上，那条路就像我老家小县城城区的那几条商业街一样，车来车往，路人行色匆匆，偶尔有两个忧郁青年会在路牌下停留，跟路牌凹一个能发社交媒体的造型，我可以想象他们的耳机里听的是什么，在那天晚上是不是会在朋友圈里多抄上几句歌词，无病呻吟一番，也许多年以前我也会，只是现在我不会。我去看32路穿过挹江门，但是它却不给我记录的机会，在我放下相机的时候匆匆驶来，又在我端着相机守候的时候姗姗来迟；我想去看纪念碑，但是施工队架起的围栏阻挡了我的视野；我走过了盐仓桥、走过了南京火车西站，却没有寻觅到秋林龙虾现在开在了哪里；我看到了也有情侣手牵手走过，谁说没有人在热河路谈恋爱？我在直线和曲线之间迷路，我气喘吁吁，我问自己如果没有来过这里，如果没有走过那些路，现在的我是否会过的很幸福？我不知道。</p>
<p>春天我去了楚翘城，去了他开的琴行，只是他的琴太贵，我拨了拨琴弦装作对吉他的音色很有研究似的点了点头又摇了摇头，不敢多看标价一眼就走出了商铺。也许我对他对喜欢远没有我想象的那么奢侈，至少不值一把几万的吉他，如果给个合理的标价，也许是一杯比星巴克还贵了一点的咖啡。我走进了Livehouse楼下那间雅致的咖啡馆，在那里我能找到桌子上有野外合作社、PK14的专辑却没能找到陈小二的，我坐下来，端起咖啡，咖啡馆尽头的大落地窗下依然在排练的乐队奏出并不完美的曲调，可我的耳朵里全是so me re me re do…</p>
]]></content>
  </entry>
  <entry>
    <title>我所不能承受的“生命之轻”</title>
    <url>/2023/12/31/%E6%88%91%E6%89%80%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%9A%84%E7%94%9F%E5%91%BD%E4%B9%8B%E8%BD%BB/</url>
    <content><![CDATA[<p>我的408做的不算快，但也还算从容，离考试结束还有半小时时我便为答卷画上了句号。离考试结束还有五分钟的时候我便开始翘首以盼，等着收卷钟声的敲响。</p>
<p>那天的夕阳也是我这一年来见过的最美的夕阳，因为当你还在为焦虑、为失眠、为前程忧虑时你是永远无法感受到所谓的美好的。我要在考完初试之后好好体验一下我Steam中积压的库存、我要去紫金山看日出、我要在复试结束后去学吉他、我要……</p>
<p>当我从考场回到宾馆，我毫不犹豫的先下了那款观望已久的文明6。打开之后本以为是打打杀杀，但是当复杂的规则摆在我面前时我完全放弃了钻研的兴趣。我刚刚考完试我是来放松的不是来学规则的，接着入坑了原神和空洞骑士。原神确实是真的好玩，虽然在之前从来没有真正的玩过，但是“原神，启动”已经是算不上是家喻户晓但是至少也是妇孺皆知。空洞骑士也真很上头，除了跑图跑的是真的累，死亡扣金币扣的也是真的烦。</p>
<p>接下来的几天虽然也干了点正事，去上了两节课，写了两篇报告，也试着去读两本书。只是报告太少、GPA不再重要、GPT又太重要，以我一贯雷厉飞行的做事风格这点 assignment 并不足挂齿；我也学了点vue，把我的毕设的前端部分完成了一点；我也尝试着去为复试做一点准备，在力扣、AcWing上做点题目。但是空下来的时间还是太多，比起以前遇事不决来套卷子、还有时间要背单词的生活，我突然不知道怎么去安排这些时间，于是变成了遇事不决空洞骑士、还有时间开把原神。</p>
<p>暑假时我每天早上醒来的第一件事就是打开墨墨刷上几百个单词，现在每天早上醒来的第一件事是打开原神继续跑图。一个月前如果我突然感觉疲惫，我会去喝一杯水然后回来接着和408、数学做搏斗，现在当我打开空洞骑士一眨眼一个小时就悄悄溜走。</p>
<p>这样的生活我刚开始玩的真的很开心，但是很快我发现<strong>能这样一直游戏人生其实也是需要天赋的</strong>。而我，无论在什么方面都向来平庸，没有干正事的天赋其实也没有什么过花天酒地的生活的天赋。当我这样过到第三天，我就开始感觉游戏带给我的似乎不是快乐，而是<strong>空虚</strong>。去年寒假在家备考的时候偶尔背着自己的良心浪费了二十分钟在神将世界里，我神清气爽；现在我只是机械的打开软件，机械的控制着人物的前进，我真的想打开原神吗？我真的想打开空洞骑士吗？我只是打开了，我只是向前跳、向后跳、放大招，我不知道是我在玩游戏还是游戏在玩我。</p>
<p>于是在考完的第六天，我知道我不能再继续这样的生活了。我再次踏上了开往市区的地铁，当一次，还是上学期。我去了我想去了很久的地方，去了南京李先生的1701，去他的琴行里摸了摸我买不起的琴，坐在1701咖啡馆看着对面排练的乐队，那天没有演出，没有民谣也没有摇滚。但是半个楚翘城都贴着1701的logo，看来他真的过很好，不知道他还写不写歌了，不知道他还愤不愤怒了，不知道他是否已经知道这个世界会不会好？我又从雨花的1701跑到了下关的热河路。纪念碑旁那家开了很久的电影院早已不知所踪，就连纪念碑也被包围在地铁施工竖起来的围栏之中。我看到32路穿过了挹江门，但是当我想用相机抓拍这一刻时，32路早已消失在夜色。我又去拍了热河路的路牌，我去寻找路边的梧桐树上还有没有歌迷对于这个世界的问候，但是梧桐树上只有零碎的白漆盖掉了不只是谁写下的什么。</p>
<p>这天我跑的很累，横穿了半个南京。那天我一点钟才睡着，但是不到六点就醒来。听着室友的断断续续的鼾声，我突然开始理解了米兰·昆德拉所说的“不能承受的生命之轻”是什么。当我在焦虑今晚能不能睡得着、明早抢不抢的到图书馆我常坐的位置的时候，我如果没有闹钟可以轻轻松松睡到9点；当我每天逼着自己保证12个小时的学习时间的时候，比起做题我甚至都觉得力扣有点好玩，去浏览Steam最近又有什么折扣简直是享受；当我每天都要在图书馆从早做到晚的时候，觉得去市里遛弯是难得的奢侈，去操场上跑步也成了生活的糖果。但是当这一切真的结束了，当我真的可以从早玩到晚时，我却玩的不痛快、当我真的可以每天睡到9点再起床了我却睡不着了。</p>
<p>生命需要重量，但是我似乎总在超重和失重之间反复横跳。今天是2023年的最后一天，不到六点苏醒的我像前几天一样在早上醒来时打开了原神，我像前几天一样跑图、打怪，当我在副本中不幸被困之后我选择了退出，卸载应用。我要在今夜去登山，去迎接2024年的第一次日出。我想起疫情时被反复提及的那句话“没有一个冬天不可逾越，没有一个春天不会到来”，今早恰好看到我的一个同学也用这句话为自己的2023做了总结。我想我也许还在人生的冬季，也许冬天又还没有真的到来。但从明天起我要想去寻求不可承受的生命之重和不可承受的生命的受力平衡点。</p>
]]></content>
  </entry>
  <entry>
    <title>煎饼排序</title>
    <url>/2022/08/14/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="【算法】煎饼排序-LeetCode-969"><a href="#【算法】煎饼排序-LeetCode-969" class="headerlink" title="【算法】煎饼排序	(LeetCode 969)"></a>【算法】煎饼排序	(LeetCode 969)</h2><p>在刷知乎的时候看到一个帖子上说到比尔盖茨在大二的时候在顶尖期刊《离散数学》（<em>Discrete Mathematics</em>）上发表了一篇论文把“Pancake Soritng”的效率提升了一波，我比较好奇到底什么是“煎饼排序”，也比较好奇这位计算机领域的骄子的第一篇论文同时也是最后一片天论文究竟解决了一个什么样的问题，于是在LeetCode上确实找到了这样的一道题。</p>
<hr>
<p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p>
<p>一次煎饼翻转的执行过程如下：</p>
<p>选择一个整数 k ，1 &lt;&#x3D; k &lt;&#x3D; arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr &#x3D; [3,2,1,4] ，选择 k &#x3D; 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr &#x3D; [1,2,3,4] 。</p>
<p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p>
<p>示例：</p>
<pre><code>输入：[3,2,4,1]
输出：[4,2,4,2]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 
</code></pre>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/pancake-sorting">https://leetcode-cn.com/problems/pancake-sorting</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="2n效率的算法"><a href="#2n效率的算法" class="headerlink" title="2n效率的算法"></a>2n效率的算法</h2><p>我自己个人认为可以把这个看成一个<strong>动态规划</strong>问题，我想到的算法是每次对于数组处理数组的最后一个数字，就是将最大的数字反转到数列的最后一个位置，然后对于将数列缩短，再对这个数列前面的这个小数列进行操作。于是我写出来了下面这样一个算法</p>
<pre><code class="cpp">class Solution &#123;
public:

    void Solve(vector&lt;int&gt; &amp;arr,int n,vector&lt;int&gt; &amp;ans)&#123;
        if(n==0)
            return ;
        else &#123;
            int index=find(arr.begin(), arr.begin()+n, n)-arr.begin();
            while(index!=n-1)&#123;
                if(index==0)&#123;
                    reverse(arr.begin(),arr.begin()+n);
                    ans.push_back(n);
                &#125;
                else &#123;
                    reverse(arr.begin(),arr.begin()+index+1);
                    ans.push_back(index+1);
                &#125;
                index=find(arr.begin(), arr.begin()+n, n)-arr.begin();
            &#125;
            if(n&gt;0)
                Solve(arr,n-1,ans);
        &#125;
    &#125;
    vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) &#123;
        vector&lt;int&gt; ans;

        Solve(arr,arr.size(),ans);
        return ans;
    &#125;
&#125;;
</code></pre>
<p>大体的思路是这样的</p>
<ol>
<li>每次对于找到当前这个数列中最大的数的位置</li>
<li>把这个最大的数字翻到顶上</li>
<li>然后再把这个数字翻到最底下</li>
</ol>
<p>这个是和那个时候的大部分人的想法不谋而合的，比尔盖茨的老师那天也在课上说明了这个问题的最优解需要翻转的次数为$2n-3$,但是盖茨后来证明了最少的次数$\frac{5n+5}{3}$</p>
<h2 id="比尔盖茨的证明"><a href="#比尔盖茨的证明" class="headerlink" title="比尔盖茨的证明"></a>比尔盖茨的证明</h2><p>我们现在的这个做法是在对于每一个数字的操作是想方设法将这个数字移动到这个数字在排列中最终的位置，但Gates的想法是，我们不去找这个数字最终的位置，而是去找这个数字最终的邻居</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器实现思路</title>
    <url>/2022/08/14/%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="一个简易计算器的实现"><a href="#一个简易计算器的实现" class="headerlink" title="一个简易计算器的实现"></a>一个简易计算器的实现</h1><p>基本思路就是采用栈和逆波兰表达式的思想对于输出的算式进行求解</p>
<h2 id="1-实现两个需要用到的栈"><a href="#1-实现两个需要用到的栈" class="headerlink" title="1.实现两个需要用到的栈"></a>1.实现两个需要用到的栈</h2><p>首先定义存放在算式中用到的存放符号所用的栈和相关的栈的操作</p>
<pre><code class="c++">//实现存放符号所用的栈
typedef struct 
&#123;
    char *base;
    char *top;
    int maxsize;
&#125;Stack;
//对栈进行初始化
void InitStack(Stack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(char *)malloc(sizeof(char)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(Stack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(Stack s)
&#123;
    int lenth=s.top-s.base;
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(Stack S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(Stack &amp;S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(Stack &amp;s,char e)
&#123;
    if(is_stack_full(s))
    &#123;
        cout&lt;&lt;&quot;符号栈满&quot;&lt;&lt;endl;
        return ;
    &#125;
    *s.top=e;
    s.top++;
&#125;
</code></pre>
<p>接着实现存放数字所用的栈和相关的操作,为了在后面使用的方便，这里所有的函数都采用重载的形式</p>
<pre><code class="c++">typedef struct 
&#123;
    int *base;
    int *top;
    int maxsize;
&#125;NumberStack;
//对栈进行初始化
void InitStack(NumberStack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(int *)malloc(sizeof(int)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(NumberStack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(NumberStack s)
&#123;
    int lenth=(s.top-s.base);
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(NumberStack S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(NumberStack &amp;S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(NumberStack &amp;s,int e)
&#123;
    if(is_stack_full(s))
        &#123;
            cout&lt;&lt;&quot;数字栈满&quot;&lt;&lt;endl;
            return ;
        &#125;
    s.top[0]=e;
    s.top++;
&#125;
</code></pre>
<h2 id="2-先做点简单的，把根据符号进行四则运算的操作实现"><a href="#2-先做点简单的，把根据符号进行四则运算的操作实现" class="headerlink" title="2.先做点简单的，把根据符号进行四则运算的操作实现"></a>2.先做点简单的，把根据符号进行四则运算的操作实现</h2><p>非常简单的思路,利用switch语句判断相应的符号，并且对输入的数字进行运算</p>
<pre><code class="c++">int jisuan(char c,int a,int b)
&#123;
    switch (c) &#123;
        case &#39;+&#39;:return a+b;break;
        case &#39;-&#39;:return a-b;break;
        case &#39;/&#39;:return a/b;break;
        case &#39;*&#39;:return a*b;break;
    &#125;
&#125;
</code></pre>
<h2 id="3-实现在函数中获取数字的操作"><a href="#3-实现在函数中获取数字的操作" class="headerlink" title="3.实现在函数中获取数字的操作"></a>3.实现在函数中获取数字的操作</h2><p>由于我们是采用字符串的形式输入表达式，因此在这个过程中必然会出现不适个位数的情形，如果直接对于数字字符进行入栈操作，那么势必会出现错误</p>
<pre><code class="c++">int num=0;
            while(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
            &#123;//获取表达式中的数字并且进栈
                num=num*10;
                num+=(s[i]-&#39;0&#39;);
                i++;
            &#125;
            Push(N,num);
</code></pre>
<h2 id="4-对于整个表达试进行入栈和出栈操作"><a href="#4-对于整个表达试进行入栈和出栈操作" class="headerlink" title="4.对于整个表达试进行入栈和出栈操作"></a>4.对于整个表达试进行入栈和出栈操作</h2><pre><code class="c++">//出栈一个符号并且计算
void Pop_and_jisuan(Stack &amp;S,NumberStack &amp;N)
&#123;
    char character;
    Pop(S, character);
    int a,b;
    Pop(N, b);
    Pop(N, a);
    int n=jisuan(character, a, b);
    Push(N,n);
&#125;
//对于表达式的操作
void OperateStack(Stack &amp;S,char c,NumberStack &amp;N)
&#123;
    switch (c) &#123;
        case &#39;(&#39;:&#123;
            Push(S,c);
        &#125;break;	
        case &#39;)&#39;:
            &#123;
                char character;
                Pop(S,character);
                while(character!=&#39;(&#39;&amp;&amp;character!=&#39;#&#39;)
                &#123;
                    int n;
                    int a,b;
                    Pop(N,b);
                    Pop(N,a);
                    n=jisuan(character, a, b);
                    Push(N,n);
                    Pop(S, character);
                &#125;
            &#125;break;
        case &#39;+&#39;:
        case &#39;-&#39;:
            &#123;
                char e;
                GetTop(S,e);
                while(e==&#39;*&#39;||e==&#39;/&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
                Push(S,c);
            &#125;break;
        case &#39;*&#39;:
        case &#39;/&#39;:
            &#123;
                Push(S,c);
            &#125;break;
        case &#39;#&#39;:
            &#123;
                char e;
                GetTop(S, e);
                while(e!=&#39;#&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
            &#125;
    &#125;
&#125;
</code></pre>
<h3 id="x3D-x3D-完整代码如下-x3D-x3D"><a href="#x3D-x3D-完整代码如下-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;完整代码如下&#x3D;&#x3D;"></a>&#x3D;&#x3D;完整代码如下&#x3D;&#x3D;</h3><pre><code class="c++">#include &lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
//用来存放符号的栈的一系列操作
typedef struct 
&#123;
    char *base;
    char *top;
    int maxsize;
&#125;Stack;
//对栈进行初始化
void InitStack(Stack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(char *)malloc(sizeof(char)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(Stack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(Stack s)
&#123;
    int lenth=s.top-s.base;
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(Stack S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(Stack &amp;S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(Stack &amp;s,char e)
&#123;
    if(is_stack_full(s))
    &#123;
        cout&lt;&lt;&quot;符号栈满&quot;&lt;&lt;endl;
        return ;
    &#125;
    *s.top=e;
    s.top++;
&#125;
//用于存放数字的栈的操作
typedef struct 
&#123;
    int *base;
    int *top;
    int maxsize;
&#125;NumberStack;
//对栈进行初始化
void InitStack(NumberStack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(int *)malloc(sizeof(int)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(NumberStack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(NumberStack s)
&#123;
    int lenth=(s.top-s.base);
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(NumberStack S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(NumberStack &amp;S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(NumberStack &amp;s,int e)
&#123;
    if(is_stack_full(s))
        &#123;
            cout&lt;&lt;&quot;数字栈满&quot;&lt;&lt;endl;
            return ;
        &#125;
    s.top[0]=e;
    s.top++;
&#125;
//先把计算操作写好
int jisuan(char c,int a,int b)
&#123;
    switch (c) &#123;
        case &#39;+&#39;:return a+b;break;
        case &#39;-&#39;:return a-b;break;
        case &#39;/&#39;:return a/b;break;
        case &#39;*&#39;:return a*b;break;
    &#125;
&#125;
//出栈一个符号并且计算
void Pop_and_jisuan(Stack &amp;S,NumberStack &amp;N)
&#123;
    char character;
    Pop(S, character);
    int a,b;
    Pop(N, b);
    Pop(N, a);
    int n=jisuan(character, a, b);
    Push(N,n);
&#125;
//对于表达式的操作
void OperateStack(Stack &amp;S,char c,NumberStack &amp;N)
&#123;
    switch (c) &#123;
        case &#39;(&#39;:&#123;
            Push(S,c);
        &#125;break;	
        case &#39;)&#39;:
            &#123;
                char character;
                Pop(S,character);
                while(character!=&#39;(&#39;&amp;&amp;character!=&#39;#&#39;)
                &#123;
                    int n;
                    int a,b;
                    Pop(N,b);
                    Pop(N,a);
                    n=jisuan(character, a, b);
                    Push(N,n);
                    Pop(S, character);
                &#125;
            &#125;break;
        case &#39;+&#39;:
        case &#39;-&#39;:
            &#123;
                char e;
                GetTop(S,e);
                while(e==&#39;*&#39;||e==&#39;/&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
                Push(S,c);
            &#125;break;
        case &#39;*&#39;:
        case &#39;/&#39;:
            &#123;
                Push(S,c);
            &#125;break;
        case &#39;#&#39;:
            &#123;
                char e;
                GetTop(S, e);
                while(e!=&#39;#&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
            &#125;
    &#125;
&#125;
int main() &#123;
    Stack S;
    NumberStack N;
    char s[100];
    cin&gt;&gt;s;
    int n=strlen(s);
    s[n]=&#39;#&#39;;
    s[n+1]=0;
    int i=0;
    InitStack(S,100);
    InitStack(N, 100);
    Push(S,&#39;#&#39;);
    while(s[i])
    &#123;
        if(s[i]==&#39;+&#39;||s[i]==&#39;-&#39;||s[i]==&#39;*&#39;||s[i]==&#39;/&#39;||s[i]==&#39;#&#39;||s[i]==&#39;(&#39;||s[i]==&#39;)&#39;)
        &#123;
            OperateStack(S,s[i],N);
            i++;
        &#125;
        else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
        &#123;
            int num=0;
            while(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
            &#123;//获取表达式中的数字并且进栈
                num=num*10;
                num+=(s[i]-&#39;0&#39;);
                i++;
            &#125;
            Push(N,num);
        &#125;
    &#125;
    int result;
    GetTop(N, result);
    cout&lt;&lt;&#39;=&#39;&lt;&lt;result&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>考研经验贴</title>
    <url>/2024/03/10/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在备考这一年里，我曾经拜读过大量前辈的经验贴，受益匪浅，我也希望我将我学到的一点点东西、领悟到的一点点心得倾入江河里、赠饮天下人，给还在追求梦想的这条道路上不辞辛劳、步履不停的朋友们点一盏烛火；另一方面，在备考的这一年中我也经历了无数焦虑、迷茫，我也见过了图书馆清晨的日出和晚上十一点后空无一人的教学楼，也许正如芥川龙之介所言，“删除掉我人生的任何一个瞬间，我都不能成为今天的自己”，那么我这一年有太多的瞬间我想将它们永远铭记。</p>
<h2 id="二、相关学科基础"><a href="#二、相关学科基础" class="headerlink" title="二、相关学科基础"></a>二、相关学科基础</h2><p>英语四六级分别为594和576，自认为英语的底子还算可以。</p>
<p>数学上，和数学二考试相关的科目高数上下拿了92、94，线性代数当时学的不错拿了100，本科获得过全国大学生数学竞赛的赛区一等奖，虽然我不认为自己是数学上属于很有天赋的人，但是高数的底子应该也不算差。</p>
<p>408的四门课本科都学过，因为大学几年也不是完全摆烂过来，甚至一度有希望保研，因此几门课学的也都还不错，相对于跨考的同学还是有一定的优势。</p>
<h2 id="三、选择考研与选择科软"><a href="#三、选择考研与选择科软" class="headerlink" title="三、选择考研与选择科软"></a>三、选择考研与选择科软</h2><p>相比很多到大三下学期面临人生的十字路口才开始思考出路选择考研的同学，我对于自己目标的规划开始的比较早，在大二下学期的时候，我当时知道班里应该最后会有6个保研名额，但是当时的排名我排在第7名。我认真思考了一下自己可以选择的升学路线，如果继续在保研这条道路上卷的话，理论上我依然存在拿到保研名额的资格，但是我几乎不可能挤进前三名的位置，而前三名基本是往届保研能够上岸比较好的学校的名额，但是哪怕是为了继续进入前6名的，我依然需要在绩点、竞赛、科研等多个方面投入大量的努力，这个努力丝毫不会比考研需要付出的少，同时我面对的事情更没有把握，因为作为一个不太成功的小镇做题家在之前近二十年的人生里面我没有接触过保研加分错不过的创业类竞赛、没有接触过科研、没有人告诉我怎么样去发paper，我不知道我能不能做好这些，但是我还是知道怎么样才能让自己在考场上拿一个还不错的分数，因为这是我之前十几年的求学生涯中每一天都在做的事情。</p>
<p>于是在保研佬们被作为榜样向全校宣传的时候、在我周围很多人都将获得保研名额视为大学生涯的至高荣誉时，我从保研名额的逐鹿者中跳了出来，因为<strong>我的目的是升学，不是保研，保研和考研都只是我达成目标的路径</strong>。所以在大二结束的那个暑假我退出了我之前参与的所有竞赛、科研项目。后来我退出的比赛队伍中，数学建模的两个队友拉了个新队友三人拿下了江苏省的一等奖第一名、我退出的互联网+队伍拿下了国金，在我备考期间也有人问我是否后悔，我的回答从来都是“不后悔”，现在回想，我会更有底气的说“不后悔”，没错，如果我没有退出，我可能也是那个拿下一等奖第一名的队伍中的一员、我可能手上也有所谓的国家级金奖，但是有舍才有得，这些在我看来是通向保研的铺路石，虽然考研复试也会有一定的作用，但是这些对于考研的作用更接近于是锦上添花而不是雪中送炭，当我不能保证自己获得一个可以高枕无忧的初试分数时，这些对于我的意义远没有想办法提高自己初试的分数来的实在。</p>
<p>如果说最开始点燃我走向考研路的那必然是当年在各大考研群疯传的软微圣经，我也想拿到北大学籍的那一刻，深埋我过往所有的不堪。但是很快我作出了一个正确的判断，软微的热度过高，各路高手蜂拥而至，软微也在不断提高自己对生源的要求，我自己扪心自问，我是否配的上北大，我是否配得上可以说全国所有院校当中就业最好的学院之一的北大软微，我鄙视我的灵魂，我告诉自己我不配。后来我将目光放到了北大工学院，北大工学院多年330的分数线，21408的组合似乎成为圆满top的捷径，加上我自己过往的一些经历，导致我有一定的理论力学基础，这是我整个备考期间保持最长时间的备考目标。但是在9月之后，我陷入一种极度的内耗，我会每天隔一会打开工学院的群，每看到一个本科学校好于我的我便会陷入焦虑，在报志愿前一众top3的佬涌入群中更是将我的焦虑推到了顶点，综合考虑到机械的专业以及仔细研究了很多老师研究方向发现有相当多的老师做的是和湍流计算等力学相关，虽有老师做的和机器人相关，但是我深深怀疑我是否能够在北大选到心仪的导师。最终在报志愿前经过一番犹豫还是选择了招生人数500且无科研压力的中科大软件学院，皈依圣科软。</p>
<h2 id="四、数学"><a href="#四、数学" class="headerlink" title="四、数学"></a>四、数学</h2><h3 id="基础阶段"><a href="#基础阶段" class="headerlink" title="基础阶段"></a>基础阶段</h3><p>在2022年9月末，10月初，也就是大三开学正式开学大约一个月后，我正式开始我的考研基础阶段。</p>
<p>数学的基础阶段侧重于基础概念的掌握、基本方法的了解，相比强化阶段会出现很多很精彩的解题方法而言，这个阶段还是比较枯燥的，相比张宇，武忠祥相对是更偏向学院派的老师，因此武老师的基础班个人感觉还是稍微有点枯燥的，张宇的就好很多，虽然我看到很多学长对于武老师是毫不吝啬赞美，但是基础阶段我感觉最重要的还是要能踏踏实实把基础知识听下去，张宇讲课当中会穿插很多小故事，听起来感觉没那么疲惫，比较容易集中注意力。但是千万别只顾着听宇哥讲故事了，只记得帮他去偷莱布尼茨的手稿忘了莱布尼茨公式。</p>
<p>考研数学老师很多的课程固然很引人入胜，但是不可忽视的是，做题才是备考考研数学最核心的任务，听课只是做题的辅助，通过课程去了解清楚自己本不清晰的知识点，然后游刃有余的用在习题的训练中，因此在备考初期我还是尽可能保证每天用在做题上的时间是长于用在听课上的时间。在听基础课的同时为了保证自己的刷题量、另一部分是担心自己选择张宇而错过了武老师的一些关键的地方，以及因为基础阶段的几本书确实是不难，同步刷了30讲、基础篇、660。也是在阶段，做660的过程当中发现自己的计算能力还有提升空间，于是刷了三大计算。</p>
<p>本来考研也是因为被软微圣经洗脑，想着大雪深埋圣软微，所以基础阶段其实算是按照数一来复习的，因为确实比较喜欢宇哥讲课的风格，带着将把张宇30讲的线代部分和概统部分看掉，带着做了660的对应习题。因为明显感到660的线性代数其实是过于简单了，于是顺带着做掉了李永乐的线性代数辅导讲义。</p>
<h3 id="强化阶段"><a href="#强化阶段" class="headerlink" title="强化阶段"></a>强化阶段</h3><p>我的基础阶段进行的很快10月初正式开始，在12月初已经结束了，随后开始长达五个月的强化阶段。很多人会告诫基础不牢地动山摇，因此推荐在基础阶段花费大量的时间，但是我认为持续在基础阶段投入其实边际效应是非常明显的，开始初步的投入可能会有比较大的提升————保证了自己的计算能力、掌握了基础概念，但是问题是基础阶段真正能够学到的东西其实是比较局限的，当投入过多之后其实能够得到的提升也相对有限。而强化阶段相比接触阶段实际上更值得投入精力和时间，我在强化阶段投入了接近半年的时间，了解了更精彩的解题方法，更重要的是进行了海量的练习，可能具体的时间已经很难记忆清楚我给出我的路径：</p>
<ul>
<li>在结束基础后以李正元全书作为教材进行学习，带着把880作为练习，看一张李正元，做对应章节的880</li>
<li>看武忠祥的强化课，带着写武忠祥的辅导讲义和严选题</li>
<li>做1000题，带着看了张宇18讲中的对应章节用来补充在做题当中表现的非常不好的部分</li>
<li>李林的108题</li>
</ul>
<h3 id="冲刺阶段"><a href="#冲刺阶段" class="headerlink" title="冲刺阶段"></a>冲刺阶段</h3><p>在大三下学期的期末结束，<strong>也就是7月初开始全面all in 模拟卷</strong>，关于模拟卷后面有专门的一部分谈关于模拟卷的部分。但是在这个时候每天一张模拟卷的题量其实还不够饱和，我自己感觉每天做完一套卷子之后还是希望能找点题目练一练，在七月做了330，8月开始买了晓千老师的同源压轴150，每天晚上再来做两道，开拓一下思维。</p>
<p>后期有不少博主和老师会更新每日一题，还是挺有价值的，除了贯穿整个考研始终、从不断更的武忠祥老师的每日一题，还有清华孝哥在后期会更新线性代数每日一题，质量也相当不错。姜晓千老师在最后也会更新150加餐，对于有志于冲刺极高分的同学可以关注一下。</p>
<h3 id="锐评各种数学习题书"><a href="#锐评各种数学习题书" class="headerlink" title="锐评各种数学习题书"></a>锐评各种数学习题书</h3><p><strong>题海战术</strong>是几乎贯穿我考研数学备考全过程的核心思想，数学考试是以解题为目的的考试，海量的练习对于备考过程当中天赋一般的同学取得理想成绩至关重要，我在2023年8月之前几乎刷完了市面上除了汤家凤1800系列之外所有比较有名的数学练习书，在后期主要以模拟卷为主，并刷了晓千老师的同源压轴150用于开拓思维。</p>
<p>对于大部分同学而言刷题很重要，但是想走我走过的路，去把市面上的所有书都刷一遍应该还是不必。</p>
<p>可能也正因为我几乎刷完了市面上的几乎所有数学练习书，所以我想应该是有义务来为大家测评一下市面上的所有辅导书。但是因为我自身在不同阶段的水平其实是不断进步的，因此我对辅导书难度的评判也很难做到完全的公正、客观，因此我会讲一讲自己的感受，也希望能够为大家对于辅导书的选择做一点有意义的参考。</p>
<p>先放上我统计自己刷书进度的备忘录图片镇个楼</p>
<p>![image-20240305221725330](&#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240305221725330.png)</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推荐阶段</th>
<th>锐评（全是主观，没有客观）</th>
</tr>
</thead>
<tbody><tr>
<td>武忠祥基础篇</td>
<td>基础</td>
<td>跟着武忠祥的基础课带着看还是不错的，如果是跟着张宇，其实并没有找过来再刷一刷的必要了。相比30讲，题目的难度应该是更小一点，不过基础的几本教材其实都没什么难的，我当时对于自己的题量挺焦虑的，于是基础阶段时同步着把2000年前的真题、30讲、基础篇都刷了，其实没必要。</td>
</tr>
<tr>
<td>660</td>
<td>基础</td>
<td>神！基础阶段打基础非常好的练习，填空题在基础阶段看来还是很不错的，但是进行到后期的时候回头来看660的填空题还是比较容易的。<strong>但是选择题，绝对是660的精髓，甚至可以说660的精髓就在于660的选择题，而660选择题中的精髓又在于660选择题中的概念题</strong>。即使在后期回过头来看660选择题中的概念题依然还是会有不一样的体会，对于把握概念非常有帮助。</td>
</tr>
<tr>
<td>三大计算</td>
<td>基础</td>
<td>同样也是基础阶段的神！我做这本书之前是在做660，当时的计算能力远远不达标，660中各种计算速度和正确率都差强人意，于是中间暂停下660一段时间，刷完了三大计算，还是非常值得的。这几年考研可以明显感受到计算量的加大，对于计算能力的培养是数学备考中非常重要的一个命题。三大计算就是完全对症下药的一本书，<strong>整本书全是极限、求导、积分的计算题。而在这三个部分当中，三大计算最后的积分部分应该也算得上是三大计算的精髓，几乎涵盖了所有考研常见的积分方法，吃透之后最起码积分计算的能力肯定是可以达到考研要求的</strong>。除非对于自己的计算能力非常自信的大佬，还是非常推荐去把这本书刷一刷。</td>
</tr>
<tr>
<td>张宇30讲</td>
<td>基础</td>
<td>和武忠祥基础篇还是同样的建议吧，基础的几本教材难度都不大，选一本好好刷一刷就好了，没必要像我这样这样。都刷了之后甚至会发现里面很多题都是重合的。如果一定要在这两本基础阶段比较流行的教材当中对难度分个高下，那我感觉30讲课后习题的难度还是抬高了这本书的难度。</td>
</tr>
<tr>
<td>线性代数辅导讲义</td>
<td>基础</td>
<td>这本书在之前我看到很多经验贴将这本书归类在强化阶段的用书当中，但是在我看来如果你本科的线性代数课程几乎就是摆过来的，那可能放在强化还是合理的，但<strong>如果本科的线代还是学明白了，那我认为这本书也就是一本基础书</strong>。可以对比22年-24年这几年的线性代数题目和以前的线性代数，特别是早年的，近几年的线代题目难度明显上升。李永乐虽然线代王的声明在外，编写的教材逻辑上确实很清晰，但是题目的难度还是有一点稍稍落伍的感觉，因此线代讲义在基础阶段用来打打基础还是很不错的选择，但是如果要用这本书来强化，我觉得可能适用不了最近逐年上升的数学难度</td>
</tr>
<tr>
<td>李林880</td>
<td>强化</td>
<td>虽然李林去年卷子的质量一言难尽，但是他的这本<strong>880依然可以被认为是强化阶段最好的习题之一</strong>。880的每一道题都确确实实给了你那种不偏不怪的感觉，比较平和，但是又不至于有难度不够的问题，还是挺值得做一做的。</td>
</tr>
<tr>
<td>高等数学辅导讲义</td>
<td>强化</td>
<td>跟着武忠祥的强化课来做还是很不错的，但是题目的新颖程度、难度个人感觉还是不如张宇18讲的</td>
</tr>
<tr>
<td>李正元全书</td>
<td>强化</td>
<td>质量非常高的一本书。李正元的高数部分难度在难度上和张宇十八讲难分伯仲，旦如果一定要分个高低，那单论题目的难度个人感觉还是张宇十八讲更难一点，但是李正元更可贵的是李正元全书当中<strong>很多题目会提供一些让人大开眼界的解法</strong>，比如在证明数列收敛的题目利用求导来避免繁杂的讨论，这些解法给了在面对复杂问题时有了更多的方法选择。如果说李正元的高数部分可以称得上是精彩，那么我愿用十分精彩来形容李正元全书的线性代数部分，<strong>尤承业的编写的线代部分在我看过的辅导书的线代当中无论是深度还是广度都是独一档的存在</strong>，同样，尤承业的部分也能看到很多独具一格的解法，比如不同于求已知$\Lambda$和对应特征向量求原矩阵，尤承业提供了利用线性变换的方法，这些方法未必有多优越（我个人反正是不太喜欢这样干的），但是为了最后追求高分的话，多掌握这种方法提供了一种交叉验证的角度。</td>
</tr>
<tr>
<td>李林108</td>
<td>强化</td>
<td>依然是很李林的一本书。让你感觉每道题做的时候都不偏不怪，但是很多题目当你做完之后再来琢磨其中用到的方法，每道题都能让你有很多的体会。</td>
</tr>
<tr>
<td>武忠祥严选题</td>
<td>强化</td>
<td>前期功夫没到家的时候做起来难度还是相当大的，做起来还是相当难受的。但是后来回过头看严选题当中真正的难题其实并不多，可能给我印象最深刻的难题还就是二重微分章节的最后一道证明题，真正意义上的难度极大。中值定理相关章节选的题目也还是很不错的。</td>
</tr>
<tr>
<td>张宇1000题</td>
<td>强化</td>
<td>还是肯定宇哥书籍的质量的。这本书按照难度分成了三个分组，前两个题组题目都还是相当不错的，无论是计算量还是思维量都是挺不错的。<strong>最后一个分组的题目在我看来很多都有点用力过猛了</strong>，很多题目都涉及了一些完全没有接触过的引理，题目的技巧性也过高，这部分图一乐做一做开拓开拓思维也挺好，做不出来也没必要纠结。</td>
</tr>
<tr>
<td>张宇高数18讲</td>
<td>强化</td>
<td>18讲其实我并没有系统的，像对待李正元全书和武忠祥强化篇那样系统的学习过，算是我在23年5月之后基本将重心转移到模拟卷上之后用于补缺的蓝本（查漏的功能由模拟卷完成），在那段时间基本已经开始保持比较高的做模拟卷的频率，根据模拟卷中暴露出的问题，将相关的章节、题型用18讲中对应的练习补齐（后面应该还会出一部分关于数学模拟卷的帖子，先挖个坑）。但是在经历模拟卷的洗礼之后，我是依然能够感受到18讲中题目的质量上乘。（ps:相比23版的18讲，24版的18讲当中据说是删去了很多的题目，不够充分，我描述的感受是基于23版的18讲）当中的很多题目都还是相当有设计感的。题目是很好，但是我个人觉得，如果我在基础阶段之后直接拿18讲作为强化的蓝本，应该感觉还是比较坐牢的，里面很多题目对于刚刚进行完基础阶段的同学来说实在是不友好，但是如果能够硬着头皮啃下来，对于能力的提升应该还是相当大的。</td>
</tr>
<tr>
<td>张宇线代9讲</td>
<td>强化</td>
<td>张宇9讲因为最后时间问题，我并没有仔细的去研究其中的知识点的讲解，更多是将这本书拿来把里面的例题当习题书做在后期来维持自己做线代的手感，因此评价可能不够充分，总的来说题目质量还是不错的，但是24版的线代似乎相较于之前的经历了改版，里面的<strong>例题实在是有点少</strong>，不知道25宇哥会不会将题量加回去。</td>
</tr>
<tr>
<td>李永乐330</td>
<td>强化</td>
<td>一本定位比较尴尬的书。按照李永乐他们团队的意思，这本书应该是属于冲刺阶段的一本书，但是这本书的难度完全达不到冲刺阶段应该有的难度。里面确实是有一些题目还是相当有意思的，但是大部分的题目还是很难达到冲刺阶段应该有的难度。<strong>知乎上也有人称这本书是“考研数学国家队最差的一本书”，从某些程度上来说，确实如此。</strong></td>
</tr>
<tr>
<td>同源压轴150</td>
<td>冲刺</td>
<td>这本书<strong>只推荐像我这种将市面上各种各样习题书都刷了个差不多的人使用</strong>。几乎所有的题目都来源于过往的数学竞赛还有数学专业的考研题，难度极大！书中的很多构造方法带有了浓厚的竞赛色彩，巧妙到让你无话可说，但是考研的压轴题还是很难见到技巧性如此强的方法的。学有余力的情况带着刷一刷可以用来开拓思维，但是沉溺于研究这本书中的各种奇技淫巧就大可不必了。</td>
</tr>
<tr>
<td>武忠祥17堂课</td>
<td>冲刺</td>
<td>中规中矩，比较靠后期做的书，题目质量不算差。本来是带着想看看武老师的十七堂课看，但是看了几节之后觉得收获不大，于是弃坑了配套课程，自己把书啃完了。</td>
</tr>
<tr>
<td>李艳芳900题</td>
<td>强化</td>
<td>可以说是市面上难度最大的一本习题书了，因为这本书出的时候我已经进入了all in模拟卷的阶段，所以找了电子版做了其中的一些章节作为对于模拟卷刷题的补充。保持了李艳芳老师一贯的高水准，但是难度真的不适合大部分同学，<strong>太难了，实在是太难了</strong>，大佬可以拿来作为补充。</td>
</tr>
<tr>
<td>武忠祥每日一题</td>
<td>全程</td>
<td><strong>几乎整个备考生涯中每天的第一题就是武忠祥老师的每日一题</strong>，武老师每天都题目选的都非常的好，配合上武忠祥老师每天的讲解受益匪浅。</td>
</tr>
<tr>
<td>清华孝哥线代每日一题</td>
<td>后期</td>
<td>强烈推荐一下。清华孝哥的题目不像武老师的每日一题是贯穿了备考的全过程，只是在后期更新，可以关注一下他在B站的账号。现在市面上存在的很多练习书上的线性代数题目都有一种用力不够的感觉（张宇的当然除外，甚至张宇很多题让我感觉用力过猛），我感觉我自己做到的大部分线代好题都是在模拟卷上做到的，而孝哥的题是我感觉除了模拟卷外我最集中做到线代好题的地方。基本没有什么直来直去的题目（当然，这种题目也逐渐被考研抛弃了），都是需要经过一定的思考、灵活的运用基础知识才能解决，质量还是相当不错的。</td>
</tr>
<tr>
<td>姜晓千150加餐</td>
<td>冲刺</td>
<td>和同源压轴150算是相似的风格，在考研基本是最后一个月开始更新，学有余力看看还是很有收获的。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="锐评各种模拟卷"><a href="#锐评各种模拟卷" class="headerlink" title="锐评各种模拟卷"></a>锐评各种模拟卷</h3><p>我个人对于模拟卷还是非常推崇的，我自己在整个备考期间算上真题共做了159套模拟卷，我个人认为模拟卷就是最好的查漏补缺的方式，很多前辈的建议都是在强化结束之后再开始进入刷模拟卷的阶段，<strong>我在备考当中在12月结束基础阶段之后就开始带着每隔一段时间做一套卷子，通过模拟卷当中反应的问题，在强化阶段对症下药，加强相应薄弱的知识点</strong>，在4月到6月保持了每周1-2套卷子的频率，在结束大三下学期的期末正式开始All in模拟卷，每天一套，直到正式考试前一周开始放缓，最终模拟卷的数量定格在了159，属于超额完成任务了，本来规划是数学共150分那么我就做150套。</p>
<p>同样关于是不是需要像我这样做这么多卷子，我的回答依然是没有必要，我们用数据说话，先给出我在备考期间整理的我模拟卷分数变化的折线图</p>
<p>![image-20240329170551784](&#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240329170551784.png)</p>
<p>由于我在备考期间用坚持了用excel整理各个模拟卷的情况，因此有幸得到了这样一份数据。</p>
<p>![image-20240329172017128](&#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240329172017128.png)</p>
<p>接着看我的分数的折线图我在前20张卷子基本在130左右，特别是前10张卷子虽然当时也会选择评价难度比较小的卷子来给自己找找自信，但是表现并不是很理想。20套之后这段时间可以连续冲上140，结合我的统计看了一下，这段时间刚好是在做往年的真题，往年的真题当中有大量的原题，或者至少说是原题型的题目在之前的练习当中都有反复练习，因此这段时间存在大量水分的，在这个时间段我自己非常清楚，给我一张全是新题的卷子我是一定做不到140+的。如果说真正开始稳定的能够在模拟卷当中拿到140+的分数，那就是67套之后，在这之后我开始能够稳定的将大部分难度适中甚至比较难的卷子做上140+。</p>
<p>如果抛开我的数据，谈谈我个人的感受，我的感觉也基本上是吻合的。我能感觉到从7月开始all in 模拟卷，到9月之间，也就是暑假里这两个月，我的水平是在不断进步的，从刚开始做李六做的磕磕绊绊，道后来可以轻松应对除了李艳芳之外的大部分试卷。<strong>我认为可以初步从我身上草率的得出一个结论，70套差不多是一个刚好的刷卷量。</strong>但是在9月之后，也就是做后面的90张卷子，在每天八点半到十一点半做一套数学试卷已经成为一种习惯，一种几乎一天不做就感觉手痒痒的习惯，成为一种习惯之后这个阶段其实我的提升已经不是很明显，这个阶段对我而言与其说是提升，不如说是在巩固手感，将每天八点半到十一点半做数学变成了一种肌肉记忆。<strong>我也非常建议大家在后期模拟的时候，每天八点半到十一点半来练习，或者最好在整个备考过程当中，在这个时间段来看数学，形成一种习惯，那么在12月的倒数第二个周日，一切都是水到渠成。</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>难度</th>
<th>主观感受</th>
</tr>
</thead>
<tbody><tr>
<td>23李林四套卷</td>
<td>简单</td>
<td>自信四套卷，基本白给。</td>
</tr>
<tr>
<td>23张宇八套卷</td>
<td>困难</td>
<td>我是在自己实力还没有明显增强的时候做的张八，从李四到张八，堪称从天堂到地狱，计算量很大，题目很新颖。</td>
</tr>
<tr>
<td>23李林六套卷</td>
<td>中等</td>
<td>质量至少远比24年的李六是要高的，难度适中，不偏不怪，除了可能有些题目还是老题，普遍被认为是<strong>比较贴近奇数年真题难度的模拟卷，但是还是达不到偶数年难度应该达到的高度。</strong></td>
</tr>
<tr>
<td>22年超越卷</td>
<td>中等偏上</td>
<td>做22超越卷的时间是<strong>我个人认为我解题能力提升最快的一段时间</strong>，22超越卷的题目出的非常好，<strong>既保重了一定的计算量上的压力，同时有很多很需要思维的题目（这些题目如果你暴力计算不是不能做，但是如果你能花一点时间去想到简便方法会大大减小计算压力）</strong>，是非常值得做的一套模拟卷。</td>
</tr>
<tr>
<td>22李六</td>
<td>中等偏下</td>
<td>同样是符合李林一贯的风格，题目<strong>不偏不怪</strong>，但是也存在问题——题目的<strong>新颖程不够</strong>，能够贴合奇数年的试题难度，但是如果说要达到偶数年的试题难度还是用力不够。</td>
</tr>
<tr>
<td>22、23、24李艳芳三套卷</td>
<td>极困难</td>
<td>李艳芳老师的卷子出了21年的，21年其实也就和张宇八套卷难度差不多，后面每一年的卷子都及困难，<strong>但是我强烈建议目标在120+的同学都要去做一做李艳芳老师的卷子，李艳芳的卷子可以说每一道题都是好题，每一道题都是经过精心设计的题目，</strong>仔细研究解析能够从每一道题当中都学到很多东西。和某些其他老师的题目难不一样，有部分老师，为了加大试卷的难度，他会把本来能够作为一道大题出的题目改成一道小题，或者在某个题目上叠上非常离谱的计算量，<strong>但是李艳芳老师不会，她的每一道难题给你的感觉不是为了难而难，而是真的经过了精心的设计。</strong>最后还要特别提一下李艳芳老师给数二出的线代小题，难度极大，不要自闭（doge</td>
</tr>
<tr>
<td>22张八</td>
<td>简单</td>
<td>22年算是宇哥恰烂钱的一年，小题的难度来源于这个题本来就是大题或者硬往上加计算量，大题出的更是毫无设计感，特别是后四张卷子，全都是信心卷。</td>
</tr>
<tr>
<td>22方浩十套卷</td>
<td>较困难</td>
<td>如果说李艳芳的卷子最精彩的地方是李艳芳的小题，<strong>那么方浩卷子最精彩的一定是他的大题</strong>。方浩的大题是我做过的所有试卷当中整体难度最大的大题，无论是计算量还是思维量。但是这套卷子不必死磕，后来我发现他的部分大题其实是有超纲的成分在里面，把原本是数学类做的题目搬给非数学类来做。</td>
</tr>
<tr>
<td>21李艳芳三套卷</td>
<td>中等偏上</td>
<td>21年是李艳芳老师第一年出试卷，还没确立她压力满满的风格，但是题目的质量还是很高的。</td>
</tr>
<tr>
<td>22李四、21李六</td>
<td>中等偏下</td>
<td>题目难度一般，新颖程度不够，相对于现代的考研其实有一点落伍。</td>
</tr>
<tr>
<td>22、23、24森哥五套卷</td>
<td>中等</td>
<td>森哥的题目也是和李林一样，给我一种更像奇数年真题的感觉，难度适中，部分题目有一定的计算量，但是创新性上还是比不上近几年的张宇和李艳芳</td>
</tr>
<tr>
<td>23超越、共创、21超越、共创</td>
<td>中等</td>
<td>这四套卷子实在是不是让我印象深刻的卷子。。。算不上特别困难，但也谈不上很容易，中规中矩。但可能这也正是超越和共创的价值所在，除了22年确实是难度比较大，其他的还是最大限度的还原了考生在考场上应该看到的难度。</td>
</tr>
<tr>
<td>23汤八</td>
<td>中等</td>
<td>每一套卷子都<strong>计算量极大</strong>，如果说思维量大，那这卷子还真谈不上，但是计算量是真的大，我自认为计算能力还是比较过关，算起来的时候也是感到压力满满。</td>
</tr>
<tr>
<td>23张四</td>
<td>较困难</td>
<td><strong>前两套的思维量和计算量都大到让人自闭，难度非常大</strong>，后两套就显得相比前面的两套友好了不少，前两套，尤其是第二套，题目还是出的很精彩的，值得好好研究一下。</td>
</tr>
<tr>
<td>23李永乐三套卷</td>
<td>容易</td>
<td>题目难度基本白给的信心卷</td>
</tr>
<tr>
<td>24李永乐六套卷</td>
<td>中等偏下</td>
<td>题目新颖程度不够，设计感不足。</td>
</tr>
<tr>
<td>24张八、张四</td>
<td>中等偏上</td>
<td>我个人认为这就是<strong>24考研所有模拟卷中质量最高的模拟卷</strong>。新颖，真的新颖，设计的非常好，非常能学到东西的两份试卷。</td>
</tr>
<tr>
<td>24李六李四</td>
<td>中等偏下</td>
<td>如果说22年是宇哥最恰烂钱的一年，那24年绝对就是李林最恰烂钱的一年。老题一堆，打飞机更是年年打，好多题目都能在880里面找到原型，甚至于是原题，更别提其中层出不穷的错题、解析中的错误。</td>
</tr>
<tr>
<td>24超越</td>
<td>中等偏上</td>
<td>质量也极高。前四张难度非常大，题目非常新颖，后面四张可能为了不够大家心态，难度降低了。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="五、408（未完待续）"><a href="#五、408（未完待续）" class="headerlink" title="五、408（未完待续）"></a>五、408（未完待续）</h2><p>我很喜欢之前某位学长对于408的比喻，学408就像是高中的时候学生物，不同的是408是学的是计算机这个硅基生物的生物学，计算机组成就是去学这个硅基生物的身体结构，学操作系统就是学这个硅基生命的身体结构，学编程和数据结构就是学和这个硅基生命交流的语言，学计算机网络就是去了解这些硅基生命是怎么和同类进行交流。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h2 id="英语（未完待续）"><a href="#英语（未完待续）" class="headerlink" title="英语（未完待续）"></a>英语（未完待续）</h2><h2 id="六、政治"><a href="#六、政治" class="headerlink" title="六、政治"></a>六、政治</h2><p>我从高中开始文科就没有真正的学好过，即使在安徽这样一个大水区，最终也只是刚刚过70分，如果在这说是经验分享实在是谈不上经验。如果一定要给几点忠告的话，肯定有两点是政治千万别开太早，也千万别投入太多的时间。下面也是大致给出我政治备考的时间线。</p>
<ul>
<li>8月开始看政治课，这个时候政治对我而言最大的意义其实是每天学累了之后的休闲选项，暑假在家里学到11点之后开始打开的徐涛的网课，听徐涛讲讲故事，带着在核心考案上把他讲的重点划下来，但是实际上这些划下来的东西和核心考案这本书在我结束了基础阶段之后我就再也没有打开过。</li>
<li>9月、10月接着看徐涛的网课，同时开始带着做1000题。这个时候政治对于我而言依然是每天学累了之后的消遣选项，每天10点从图书馆闭馆出来之后我找到了一间能够呆到十一点半的教室，回到教室一边摸鱼一边做肖1000。但是后来对答案发现实在是错的太多了，于是在摸鱼的同时还去B站听了一点张修齐的讲解，但是也实在是没记住多少东西。</li>
<li>11月模拟卷到手，开始疯狂刷模拟卷。这个时候政治再像之前边摸鱼边学实在是说不过去了，于是我开始将原来每天吃完晚饭之后分给英语的时间当中选择一部分留给政治，用来刷模拟卷。</li>
<li>12月死到临头的时候才知道自己对于政治有多大的热情。每天吃完晚饭后留给英语的时间全部留给政治，用来做政治的模拟卷，苍盾上的卷子基本都做了一遍。随后肖四到手，开始背肖四。但是肖四实在是太多了，我也确实是非常不擅长背书，找了研木易的精简版结合着肖四后面的大纲记住了关键词。在考试前一天猛背了一天政治，最后多亏选择题做的还不错，大题因为我自己书写一直问题比较大，字迹潦草，感谢改卷老师，让我分数还是突破了70。</li>
</ul>
]]></content>
  </entry>
</search>
