<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL入门</title>
    <url>/2022/08/13/SQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="写在开头的几点事情"><a href="#写在开头的几点事情" class="headerlink" title="写在开头的几点事情"></a>写在开头的几点事情</h2><ol>
<li>mysql中的关键字不区分大小写也就是说 SELECT,select ,Select都是一样的管用</li>
<li>对于我们自己定义的属性的名称，虽然我们可以直接写写属性的名称，但是为了避免和关键走出现冲突常常使用”&#96;&#96;“将我们自定义的词语包括在其中</li>
<li>mysql中的注释语句目前我知道的有三种写法</li>
</ol>
<h2 id="数据基本操作"><a href="#数据基本操作" class="headerlink" title="数据基本操作"></a>数据基本操作</h2><pre><code class="mysql">CREATE DATABASE `learn_sql`; -- 创建数据库
SHOW DATABASES; -- 显示现在所有的数据库
USE `learn_sql`;  -- 开始使用某个数据库
</code></pre>
<h2 id="创建表格并操作"><a href="#创建表格并操作" class="headerlink" title="创建表格并操作"></a>创建表格并操作</h2><pre><code class="mysql">CREATE TABLE `student`(
    `student_id` INT PRIMARY KEY,-- 数据名称 数据类型，有一个数据为主键(primary key)
    `name` VARCHAR(20),  -- 字符串数据类型，VERCHAR(字符串长度)
    `major` VARCHAR(20) DEFAULT &#39;计算机&#39; -- 可以给某个数据类型默认值，这里默认的专业为计算机
);

DESCRIBE `student`;-- 显示表格里面各项数据及其类型
DROP TABLE `student`;-- 删除表格

ALTER TABLE `student` ADD gpa DECIMAL(3,2);-- 对于表格加入属性
</code></pre>
<h2 id="对于表格中的数据进行操作"><a href="#对于表格中的数据进行操作" class="headerlink" title="对于表格中的数据进行操作"></a>对于表格中的数据进行操作</h2><pre><code class="mysql">INSERT INTO `student` VALUES (2,&#39;小黑&#39;,&#39;生物&#39;,&#39;4.0&#39;);-- 插入数据
INSERT INTO `student` VALUES (3,&#39;小绿&#39;,NULL,NULL);-- 有的项目不想填的话直接写成null

INSERT INTO `student`(`name`,`major`,`studnet_id`,`gpa`) VALUES (&#39;小红&#39;,NULL,4,NULL);-- 可以在前面写东西来限制加入的属性的顺序

SELECT * FROM `student`; -- 用来查看表格中的所有数据。*在数据库中表示的是全部的意思
</code></pre>
<h2 id="在对于数据库中的数据做限制"><a href="#在对于数据库中的数据做限制" class="headerlink" title="在对于数据库中的数据做限制"></a>在对于数据库中的数据做限制</h2><pre><code class="mysql">--  constrain 限制
DROP Table `student`;
-- 在创建数据库时对于数据类型进行限制
CREATE TABLE `student`(
    `student_id` INT PRIMARY KEY,
    `name` VARCHAR(20) NOT NULL,-- 非空
    `major` VARCHAR(20) UNIQUE -- 不能重复
);
</code></pre>
<h2 id="对于数据库中进行增删改查"><a href="#对于数据库中进行增删改查" class="headerlink" title="对于数据库中进行增删改查"></a>对于数据库中进行增删改查</h2><pre><code class="mysql">INSERT INTO `student` VALUES (2,&#39;小黑&#39;,&#39;生物&#39;);-- 插入数据
INSERT INTO `student` VALUES (3,&#39;小绿&#39;,NULL);

DROP Table `student`;-- 删除表格

CREATE TABLE `student`(
    `student_id` INT AUTO_INCREMENT ,
    `name` VARCHAR(20) ,     
    `major` VARCHAR(20),
    PRIMARY KEY(`student_id`)
);

INSERT INTO `student` VALUES (1,&#39;小黑&#39;,&#39;生物&#39;);
INSERT INTO `student` VALUES (2,&#39;小绿&#39;,NULL);
INSERT INTO `student`(`name`,`major`) VALUES (&#39;小黄&#39;,&#39;计算机&#39;);

SELECT * FROM `student`;

-- 修改删除数据

SET SQL_SAFE_UPDATES=0;

CREATE TABLE `student`(
    `student_id` INT AUTO_INCREMENT ,
    `name` VARCHAR(20) ,     
    `major` VARCHAR(20),
    PRIMARY KEY(`student_id`),
    `score` INT
);

INSERT INTO `student` VALUES (1,&#39;小黑&#39;,&#39;生物&#39;,90);
INSERT INTO `student` VALUES (2,&#39;小绿&#39;,&#39;生物&#39;,70);
INSERT INTO `student`(`name`,`major`,`score`) VALUES (&#39;小黄&#39;,&#39;计算机&#39;,91);

SELECT * FROM `student`;

-- 修改
UPDATE `student` 
SET `major`= &#39;生命科学&#39;
WHERE `major`=&#39;生物&#39;;

-- 删除
DELETE FROM `student`
WHERE `score`&lt;80;

SELECT * FROM `student`;

-- 查询数据

SELECT `name`,`major` FROM`student`;
#查询时从低到高排序
SELECT * 
FROM `student`
ORDER BY `score` ;

#查询时从高到低排序
SELECT * 
FROM `student`
ORDER BY `score`,`student_id` DESC
LIMIT 1;

SELECT `name`,`major` FROM`student` limit 1;

SELECT *
FROM `student`
WHERE `major`=&#39;计算机&#39;;

SELECT *
FROM `student`
WHERE `major`IN(&#39;计算机&#39;,&#39;历史&#39;,&#39;生命科学&#39;);
</code></pre>
<h2 id="创建一个含有多个表格的复杂数据库"><a href="#创建一个含有多个表格的复杂数据库" class="headerlink" title="创建一个含有多个表格的复杂数据库"></a>创建一个含有多个表格的复杂数据库</h2><pre><code class="mysql">-- 创建比较复杂的数据库（创建一个简单的公司资料库）
DROP TABLE `student`;

CREATE table`employee`(
    `emp_id` INT PRIMARY KEY,
    `name` VARCHAR(20),
    `birth_date` DATE,
    `sex` varchar(20),
    `salary` int,
    `branch_id` int,
    `sup_id` int
);

create table `branch`(
    `branch_id` int primary key,
    `branch_name` varchar(20),
    `manager_id` int,
    foreign key(`manager_id`) references `employee`(`emp_id`) on delete set null
);

create table `client`(
    `client_id` int primary key,
    `client_name` varchar(20),
    `phone` varchar(20)
);

create table `work_with`(
    `emp_id` int,
    `client_id` int ,
    `total_sales` int,
    foreign key (`emp_id`) references `employee`(`emp_id`) on delete cascade,
    foreign key (`client_id`) references `client`(`client_id`) on delete cascade
);


#补上由于之前表格没有创建完而缺少的foreign key
alter table `employee`
add foreign key(`branch_id`)
references `branch`(`branch_id`) on delete set null;

alter table `employee`
add foreign key(`sup_id`) references `employee`(`emp_id`) on delete set null;

#插入数据
##所有有foreign key指向的那个东西必须先存在
# 这里我们选择先创建部门，然后把部门经理全部设置为null然后在后面创建员工表格的时候再把这个改回来
insert into `branch` values(1,&#39;行政&#39;,null);
insert into `branch` values(2,&#39;研发&#39;,null);
insert into `branch` values(3,&#39;资讯&#39;,null);

insert into `employee` values(206,&#39;小黄&#39;,&#39;1998-10-08&#39;,&#39;F&#39;,5000,1,null);
insert into `employee` values(207,&#39;小绿&#39;,&#39;1985-09-16&#39;,&#39;M&#39;,2900,2,206);
insert into `employee` values(208,&#39;小黑&#39;,&#39;2000-12-19&#39;,&#39;M&#39;,3500,3,206);
insert into `employee` values(209,&#39;小白&#39;,&#39;1997-01-22&#39;,&#39;F&#39;,3900,3,207);
insert into `employee` values(210,&#39;小蓝&#39;,&#39;1925-11-10&#39;,&#39;F&#39;,8400,1,207);

update `branch` set `manager_id`=208 where `branch_id`=3;
insert into `client` values(400,&#39;阿猫&#39;,&#39;13987655908&#39;);
insert into `client` values(401,&#39;阿狗&#39;,&#39;13987655912&#39;);
insert into `client` values(402,&#39;旺来&#39;,&#39;15487655908&#39;);
insert into `client` values(403,&#39;露西&#39;,&#39;18887655908&#39;);
insert into `client` values(404,&#39;艾萨克&#39;,&#39;1987655908&#39;); 

insert into `work_with` values(206,400,70000);
insert into `work_with` values(207,401,2400);
insert into `work_with` values(208,402,9800);
insert into `work_with` values(208,403,24000);
insert into `work_with` values(210,404,87940);

select * from  `branch`;
select * from `employee`;
update `branch` set `manager_id`=206 where `branch_id`=1;
update `branch` set `manager_id`=207 where `branch_id`=2;


-- 数据库操作练习
-- 1.获得员工的数据
select * from `employee`;
-- 2.获得客户资料
select * from `client` ;
-- 3.按照薪水对于员工进行排序
select * from `employee` order by `salary` desc;
select * from `employee` order by `salary` ;
-- 4.获得工资前三高的员工
select * from `employee` order by `salary` desc limit 3;
-- 5.获取所有员工的名字
select `name` from `employee`;
-- 6.不重复的获得性别
select distinct `sex` from `employee`;



-- aggregate function 聚合函数
-- 1.取得员工人数
select count(*) from `employee`;
select count(`sup_id`) from `employee`;
-- 2.取得出生在特定日期之后的女性员工人数
select count(*) from `employee` where `birth_date`&gt;&#39;1970_01_01&#39; and `sex`=&#39;M&#39;;
-- 3.取得所有员工的平均薪水
select avg(salary) from employee;
-- 4.取得所有员工薪水的总和
select sum(`salary`) from `employee`;
-- 5.找出薪水最高/低的员工
select max(`salary`) from `employee`;
select min(`salary`) from `employee`;


-- wildcards 万用字元。%代表多个字元。 _代表一个字元
-- 1.取得电话尾号为335的用户
select * from `client` where `phone` like &#39;%335&#39;;
-- 2.去的姓氏为‘阿’的客户
select * from `client` where `client_name` like &#39;阿%&#39;;
-- 3.生日在12月的员工
select * from `employee` where `birth_date` like &#39;%12%&#39;;
select * from `employee` where `birth_date` like &#39;_____12%&#39;;



-- union 联集
-- 1.员工的名字union客户的名字
select `name` from employee
union
select `client_name` from `client`;
-- 2.员工ID+员工名字 union 客户ID+客户名字
select `emp_id`as `total_id`,`name` as `total_name` from `employee` union select `client_id`,`client_name`from `client`; 
-- 合并数据类型要一样，数据数目要一样



-- join 连接
insert `branch` values(4,&#39;偷懒&#39;,null);
-- 取的所有部门经理的名字
select * from employee  join branch on emp_id= manager_id;
select `emp_id`,`name`,`branch_name` from employee  join branch on `employee`.`emp_id` = `branch`.`manager_id`;
select `emp_id`,`name`,`branch_name` from employee  left join branch on `employee`.`emp_id` = `branch`.`manager_id`; #只要左边的表格成立就可以回传资料



-- subquery子查询

-- 1.找出研发部门经理的名字
select `name` from employee where emp_id=(
    select `manager_id` 
    from `branch`
    where `branch_name` =&#39;研发&#39;
);
-- 2.找出对于一位客户销售额超过5000的员工的名字
select `name` from employee where emp_id in(
    select `emp_id` 
    from `work_with`
    where `total_sales` &gt; 50000
);
</code></pre>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Markdown入门</title>
    <url>/2022/08/15/Markdown%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Markdown入门"><a href="#Markdown入门" class="headerlink" title="Markdown入门"></a>Markdown入门</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
  cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;
&#125;
</code></pre>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><table>
<thead>
<tr>
<th align="center">你好</th>
<th align="right">你好</th>
<th align="left">你好</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有点意思</td>
<td align="right">有点意思</td>
<td align="left">有点意思</td>
</tr>
<tr>
<td align="center">什么</td>
<td align="right">好家伙</td>
<td align="left">好吧</td>
</tr>
<tr>
<td align="center">冲冲冲</td>
<td align="right">我爱C++</td>
<td align="left">什么东西</td>
</tr>
</tbody></table>
<p><strong>粗体</strong></p>
<p><em>倾斜</em></p>
<p><em><strong>斜体加粗</strong></em><br><del>删除线</del></p>
<p>&#x3D;&#x3D;高亮&#x3D;&#x3D;</p>
<p>我是^上标^</p>
<p>我是<del>小标</del></p>
<p>&#x3D;&#x3D;列表&#x3D;&#x3D;</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>一二三四五<ul>
<li>有点意思</li>
<li>呵呵哒<ul>
<li>你好哇</li>
</ul>
</li>
</ul>
</li>
<li>上山打老虎</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>&#x3D;&#x3D;引用&#x3D;&#x3D;</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<blockquote>
<blockquote>
<p>一二三四五</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一二三四五</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>分割线</p>
<p>&#x3D;&#x3D;LateX语法&#x3D;&#x3D;<br>$$<br>y&#x3D;x^2+2<br>$$</p>
<p>$$<br>\lfloor x\rfloor<br>\lceil y \rceil<br>\uparrow<br>\downarrow<br>\updownarrow<br>\backslash<br>\ulcorner<br>\llcorner<br>\urcorner<br>\lrcorner<br>|<br>\mathscr{ABCD 1234}<br>\mathfrak{ABCD 1234}<br>\mathbb{ABCDabcdefg 12345}<br>$$</p>
<p>$$<br>希腊字母<br>\alpha<br>\beta<br>\gamma<br>\epsilon<br>\zeta<br>A<br>\Delta<br>\delta<br>\Xi<br>\Lambda<br>\lambda<br>\sigma<br>\Sigma<br>\upsilon<br>\phi<br>\chi<br>\Phi<br>\varPsi<br>\pi<br>\rho<br>$$</p>
<p>$$<br>运算符\pm<br>\cdot<br>\cup<br>\oplus<br>\odot<br>\mp<br>\star<br>\times<br>\otimes<br>\setminus<br>\div<br>$$</p>
<p>$$<br>E&#x3D;m\cdot<br>c^2<br>$$</p>
<p>$$<br>二元关系符号:&lt; \ll \prec \sim \subset \in \parallel \asymp \gg \neq \approx\propto \notin \equiv \supset \ni \perp \leq \ge \subseteq \ni \simeq \cong<br>$$</p>
<p>$$<br>二元关系： \because  \subsetneqq \therefore\supsetneqq \ngtr \nless<br>$$</p>
<p>$$<br>\leftarrow   \rightarrow \leftrightarrow \nearrow \swarrow \Leftarrow \Rightarrow\longleftarrow<br>\Longleftarrow \Longleftrightarrow \circlearrowleft \nLeftarrow \nRightarrow \nleftarrow<br>\nrightarrow \leftrightarrows<br>$$<br>$$<br>其他符号：\forall \exist \nabla \ell \jmath \dots \cdots \vdots \ddots \aleph \S  \P<br>\angle  \infty<br>\heartsuit \hbar \hslash \bigstar \square \varnothing \measuredangle<br>$$</p>
<p>$$<br>\sin<br>\cos<br>\arccos<br>\arcsin<br>\arctan<br>\tan<br>\cot<br>\arctan<br>\cot<br>\sec<br>\cosh<br>\sinh<br>\min<br>\max<br>a^3_{ij}<br>{a_{ij}}^3<br>{}^{12}_{6}\mathrm{C}<br>$$</p>
<p>$$<br>微积分符号:\dot{x}&#x3D;v<br>$$</p>
<p>$$<br>\ddot{x}&#x3D;\dot{v}<br>$$</p>
<p>$$<br>y’&#x3D;x \qquad \int ^{death}_{birth}time &#x3D;life\qquad \iint_sE\cdot ds&#x3D;Q\cdot \epsilon_0\qquad 分式\frac{y}{x}\qquad \tfrac{a}{b}\qquad<br>$$</p>
<p>$$<br>\sqrt{2}\qquad\sqrt[3]{x}\qquad \overline{m+n} \qquad \underbrace{a_1+a_2+\ldots+a_n}_{n}<br>\qquad \underbracket[0.4pt][1ex]{a_1+a_2+\cdots+a_n}_n\quad a\xleftarrow{x+y+z} b<br>\qquad a\xrightarrow[x&lt;y]{a<em>b</em>c}d\qquad \hat A \qquad \hat{AB}\qquad<br>$$</p>
<p>$$<br>\qquad \tilde{C} \quad \widetilde{CD}\qquad A\overset{abc}{&#x3D;}B \qquad A\underset{b}{&#x3D;}C\quad 去心邻域\mathring{U}\qquad \sum_{i&#x3D;1}^n\qquad \prod_{j&#x3D;1}^{n}\qquad \sideset{_a^b}{_c^d}\sum<br>$$</p>
<p>$$<br>\sum_{\substack{0&lt;i&lt;n\0&lt;j&lt;m}}p_{ij}&#x3D;\prod_{\substack{i\in n\1&lt;j&lt;m}}q_{ij}\qquad \max\limits_{i&gt;1}^{x}\quad \mathop{xyz}\limits_{x&gt;0}<br>$$</p>
<p>$$<br>关于矩阵：\begin{pmatrix}0&amp;1\1&amp;0\end{pmatrix}<br>$$</p>
<p>$$<br>y&#x3D;\begin{cases}\int x,&amp;x&gt;0 \ 0, &amp;x&#x3D;0\ x-1 ,&amp;x&lt;0 \end{cases},x\in\mathbb{R}<br>$$</p>
<hr>
<h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>![理论](&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;截屏2021-01-30 16.35.22.png)</p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>[github](https:<a href="http://www.github.com/">www.github.com</a></p>
<pre><code class="mermaid">graph TD;
A--&gt;B;
B--&gt;C;
C--&gt;A;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>煎饼排序</title>
    <url>/2022/08/14/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="【算法】煎饼排序-LeetCode-969"><a href="#【算法】煎饼排序-LeetCode-969" class="headerlink" title="【算法】煎饼排序	(LeetCode 969)"></a>【算法】煎饼排序	(LeetCode 969)</h2><p>在刷知乎的时候看到一个帖子上说到比尔盖茨在大二的时候在顶尖期刊《离散数学》（<em>Discrete Mathematics</em>）上发表了一篇论文把“Pancake Soritng”的效率提升了一波，我比较好奇到底什么是“煎饼排序”，也比较好奇这位计算机领域的骄子的第一篇论文同时也是最后一片天论文究竟解决了一个什么样的问题，于是在LeetCode上确实找到了这样的一道题。</p>
<hr>
<p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p>
<p>一次煎饼翻转的执行过程如下：</p>
<p>选择一个整数 k ，1 &lt;&#x3D; k &lt;&#x3D; arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr &#x3D; [3,2,1,4] ，选择 k &#x3D; 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr &#x3D; [1,2,3,4] 。</p>
<p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p>
<p>示例：</p>
<pre><code>输入：[3,2,4,1]
输出：[4,2,4,2]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 
</code></pre>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/pancake-sorting">https://leetcode-cn.com/problems/pancake-sorting</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="2n效率的算法"><a href="#2n效率的算法" class="headerlink" title="2n效率的算法"></a>2n效率的算法</h2><p>我自己个人认为可以把这个看成一个<strong>动态规划</strong>问题，我想到的算法是每次对于数组处理数组的最后一个数字，就是将最大的数字反转到数列的最后一个位置，然后对于将数列缩短，再对这个数列前面的这个小数列进行操作。于是我写出来了下面这样一个算法</p>
<pre><code class="cpp">class Solution &#123;
public:

    void Solve(vector&lt;int&gt; &amp;arr,int n,vector&lt;int&gt; &amp;ans)&#123;
        if(n==0)
            return ;
        else &#123;
            int index=find(arr.begin(), arr.begin()+n, n)-arr.begin();
            while(index!=n-1)&#123;
                if(index==0)&#123;
                    reverse(arr.begin(),arr.begin()+n);
                    ans.push_back(n);
                &#125;
                else &#123;
                    reverse(arr.begin(),arr.begin()+index+1);
                    ans.push_back(index+1);
                &#125;
                index=find(arr.begin(), arr.begin()+n, n)-arr.begin();
            &#125;
            if(n&gt;0)
                Solve(arr,n-1,ans);
        &#125;
    &#125;
    vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) &#123;
        vector&lt;int&gt; ans;

        Solve(arr,arr.size(),ans);
        return ans;
    &#125;
&#125;;
</code></pre>
<p>大体的思路是这样的</p>
<ol>
<li>每次对于找到当前这个数列中最大的数的位置</li>
<li>把这个最大的数字翻到顶上</li>
<li>然后再把这个数字翻到最底下</li>
</ol>
<p>这个是和那个时候的大部分人的想法不谋而合的，比尔盖茨的老师那天也在课上说明了这个问题的最优解需要翻转的次数为$2n-3$,但是盖茨后来证明了最少的次数$\frac{5n+5}{3}$</p>
<h2 id="比尔盖茨的证明"><a href="#比尔盖茨的证明" class="headerlink" title="比尔盖茨的证明"></a>比尔盖茨的证明</h2><p>我们现在的这个做法是在对于每一个数字的操作是想方设法将这个数字移动到这个数字在排列中最终的位置，但Gates的想法是，我们不去找这个数字最终的位置，而是去找这个数字最终的邻居</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器实现思路</title>
    <url>/2022/08/14/%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="一个简易计算器的实现"><a href="#一个简易计算器的实现" class="headerlink" title="一个简易计算器的实现"></a>一个简易计算器的实现</h1><p>基本思路就是采用栈和逆波兰表达式的思想对于输出的算式进行求解</p>
<h2 id="1-实现两个需要用到的栈"><a href="#1-实现两个需要用到的栈" class="headerlink" title="1.实现两个需要用到的栈"></a>1.实现两个需要用到的栈</h2><p>首先定义存放在算式中用到的存放符号所用的栈和相关的栈的操作</p>
<pre><code class="c++">//实现存放符号所用的栈
typedef struct 
&#123;
    char *base;
    char *top;
    int maxsize;
&#125;Stack;
//对栈进行初始化
void InitStack(Stack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(char *)malloc(sizeof(char)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(Stack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(Stack s)
&#123;
    int lenth=s.top-s.base;
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(Stack S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(Stack &amp;S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(Stack &amp;s,char e)
&#123;
    if(is_stack_full(s))
    &#123;
        cout&lt;&lt;&quot;符号栈满&quot;&lt;&lt;endl;
        return ;
    &#125;
    *s.top=e;
    s.top++;
&#125;
</code></pre>
<p>接着实现存放数字所用的栈和相关的操作,为了在后面使用的方便，这里所有的函数都采用重载的形式</p>
<pre><code class="c++">typedef struct 
&#123;
    int *base;
    int *top;
    int maxsize;
&#125;NumberStack;
//对栈进行初始化
void InitStack(NumberStack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(int *)malloc(sizeof(int)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(NumberStack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(NumberStack s)
&#123;
    int lenth=(s.top-s.base);
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(NumberStack S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(NumberStack &amp;S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(NumberStack &amp;s,int e)
&#123;
    if(is_stack_full(s))
        &#123;
            cout&lt;&lt;&quot;数字栈满&quot;&lt;&lt;endl;
            return ;
        &#125;
    s.top[0]=e;
    s.top++;
&#125;
</code></pre>
<h2 id="2-先做点简单的，把根据符号进行四则运算的操作实现"><a href="#2-先做点简单的，把根据符号进行四则运算的操作实现" class="headerlink" title="2.先做点简单的，把根据符号进行四则运算的操作实现"></a>2.先做点简单的，把根据符号进行四则运算的操作实现</h2><p>非常简单的思路,利用switch语句判断相应的符号，并且对输入的数字进行运算</p>
<pre><code class="c++">int jisuan(char c,int a,int b)
&#123;
    switch (c) &#123;
        case &#39;+&#39;:return a+b;break;
        case &#39;-&#39;:return a-b;break;
        case &#39;/&#39;:return a/b;break;
        case &#39;*&#39;:return a*b;break;
    &#125;
&#125;
</code></pre>
<h2 id="3-实现在函数中获取数字的操作"><a href="#3-实现在函数中获取数字的操作" class="headerlink" title="3.实现在函数中获取数字的操作"></a>3.实现在函数中获取数字的操作</h2><p>由于我们是采用字符串的形式输入表达式，因此在这个过程中必然会出现不适个位数的情形，如果直接对于数字字符进行入栈操作，那么势必会出现错误</p>
<pre><code class="c++">int num=0;
            while(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
            &#123;//获取表达式中的数字并且进栈
                num=num*10;
                num+=(s[i]-&#39;0&#39;);
                i++;
            &#125;
            Push(N,num);
</code></pre>
<h2 id="4-对于整个表达试进行入栈和出栈操作"><a href="#4-对于整个表达试进行入栈和出栈操作" class="headerlink" title="4.对于整个表达试进行入栈和出栈操作"></a>4.对于整个表达试进行入栈和出栈操作</h2><pre><code class="c++">//出栈一个符号并且计算
void Pop_and_jisuan(Stack &amp;S,NumberStack &amp;N)
&#123;
    char character;
    Pop(S, character);
    int a,b;
    Pop(N, b);
    Pop(N, a);
    int n=jisuan(character, a, b);
    Push(N,n);
&#125;
//对于表达式的操作
void OperateStack(Stack &amp;S,char c,NumberStack &amp;N)
&#123;
    switch (c) &#123;
        case &#39;(&#39;:&#123;
            Push(S,c);
        &#125;break;	
        case &#39;)&#39;:
            &#123;
                char character;
                Pop(S,character);
                while(character!=&#39;(&#39;&amp;&amp;character!=&#39;#&#39;)
                &#123;
                    int n;
                    int a,b;
                    Pop(N,b);
                    Pop(N,a);
                    n=jisuan(character, a, b);
                    Push(N,n);
                    Pop(S, character);
                &#125;
            &#125;break;
        case &#39;+&#39;:
        case &#39;-&#39;:
            &#123;
                char e;
                GetTop(S,e);
                while(e==&#39;*&#39;||e==&#39;/&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
                Push(S,c);
            &#125;break;
        case &#39;*&#39;:
        case &#39;/&#39;:
            &#123;
                Push(S,c);
            &#125;break;
        case &#39;#&#39;:
            &#123;
                char e;
                GetTop(S, e);
                while(e!=&#39;#&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
            &#125;
    &#125;
&#125;
</code></pre>
<h3 id="x3D-x3D-完整代码如下-x3D-x3D"><a href="#x3D-x3D-完整代码如下-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;完整代码如下&#x3D;&#x3D;"></a>&#x3D;&#x3D;完整代码如下&#x3D;&#x3D;</h3><pre><code class="c++">#include &lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
//用来存放符号的栈的一系列操作
typedef struct 
&#123;
    char *base;
    char *top;
    int maxsize;
&#125;Stack;
//对栈进行初始化
void InitStack(Stack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(char *)malloc(sizeof(char)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(Stack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(Stack s)
&#123;
    int lenth=s.top-s.base;
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(Stack S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(Stack &amp;S,char &amp;e)
&#123;
    if(is_stack_empty(S))
    &#123;
        cout&lt;&lt;&quot;符号栈空&quot;&lt;&lt;endl;
        return ;
    &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(Stack &amp;s,char e)
&#123;
    if(is_stack_full(s))
    &#123;
        cout&lt;&lt;&quot;符号栈满&quot;&lt;&lt;endl;
        return ;
    &#125;
    *s.top=e;
    s.top++;
&#125;
//用于存放数字的栈的操作
typedef struct 
&#123;
    int *base;
    int *top;
    int maxsize;
&#125;NumberStack;
//对栈进行初始化
void InitStack(NumberStack &amp;S,int size)
&#123;
    S.maxsize=size;
    S.base=(int *)malloc(sizeof(int)*size);
    S.top=S.base;
&#125;
//判断栈是否是空的
bool is_stack_empty(NumberStack S)
&#123;
    if(S.base==S.top)
        return true;
    else return false;
&#125;
//判断栈是否是满的
bool is_stack_full(NumberStack s)
&#123;
    int lenth=(s.top-s.base);
    if(lenth&lt;s.maxsize)
        return false;
    else 
        return true;
&#125;
//获得栈顶顶元素
void GetTop(NumberStack S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    e=*(S.top-1);
&#125;
//出栈操作
void Pop(NumberStack &amp;S,int &amp;e)
&#123;
    if(is_stack_empty(S))
        &#123;
            cout&lt;&lt;&quot;数字栈空&quot;&lt;&lt;endl;
            return ;
        &#125;
    S.top--;
    e=*(S.top);
&#125;
void Push(NumberStack &amp;s,int e)
&#123;
    if(is_stack_full(s))
        &#123;
            cout&lt;&lt;&quot;数字栈满&quot;&lt;&lt;endl;
            return ;
        &#125;
    s.top[0]=e;
    s.top++;
&#125;
//先把计算操作写好
int jisuan(char c,int a,int b)
&#123;
    switch (c) &#123;
        case &#39;+&#39;:return a+b;break;
        case &#39;-&#39;:return a-b;break;
        case &#39;/&#39;:return a/b;break;
        case &#39;*&#39;:return a*b;break;
    &#125;
&#125;
//出栈一个符号并且计算
void Pop_and_jisuan(Stack &amp;S,NumberStack &amp;N)
&#123;
    char character;
    Pop(S, character);
    int a,b;
    Pop(N, b);
    Pop(N, a);
    int n=jisuan(character, a, b);
    Push(N,n);
&#125;
//对于表达式的操作
void OperateStack(Stack &amp;S,char c,NumberStack &amp;N)
&#123;
    switch (c) &#123;
        case &#39;(&#39;:&#123;
            Push(S,c);
        &#125;break;	
        case &#39;)&#39;:
            &#123;
                char character;
                Pop(S,character);
                while(character!=&#39;(&#39;&amp;&amp;character!=&#39;#&#39;)
                &#123;
                    int n;
                    int a,b;
                    Pop(N,b);
                    Pop(N,a);
                    n=jisuan(character, a, b);
                    Push(N,n);
                    Pop(S, character);
                &#125;
            &#125;break;
        case &#39;+&#39;:
        case &#39;-&#39;:
            &#123;
                char e;
                GetTop(S,e);
                while(e==&#39;*&#39;||e==&#39;/&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
                Push(S,c);
            &#125;break;
        case &#39;*&#39;:
        case &#39;/&#39;:
            &#123;
                Push(S,c);
            &#125;break;
        case &#39;#&#39;:
            &#123;
                char e;
                GetTop(S, e);
                while(e!=&#39;#&#39;)
                &#123;
                    Pop_and_jisuan(S, N);
                    GetTop(S, e);
                &#125;
            &#125;
    &#125;
&#125;
int main() &#123;
    Stack S;
    NumberStack N;
    char s[100];
    cin&gt;&gt;s;
    int n=strlen(s);
    s[n]=&#39;#&#39;;
    s[n+1]=0;
    int i=0;
    InitStack(S,100);
    InitStack(N, 100);
    Push(S,&#39;#&#39;);
    while(s[i])
    &#123;
        if(s[i]==&#39;+&#39;||s[i]==&#39;-&#39;||s[i]==&#39;*&#39;||s[i]==&#39;/&#39;||s[i]==&#39;#&#39;||s[i]==&#39;(&#39;||s[i]==&#39;)&#39;)
        &#123;
            OperateStack(S,s[i],N);
            i++;
        &#125;
        else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
        &#123;
            int num=0;
            while(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;)
            &#123;//获取表达式中的数字并且进栈
                num=num*10;
                num+=(s[i]-&#39;0&#39;);
                i++;
            &#125;
            Push(N,num);
        &#125;
    &#125;
    int result;
    GetTop(N, result);
    cout&lt;&lt;&#39;=&#39;&lt;&lt;result&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>我所不能承受的“生命之轻”</title>
    <url>/2023/12/31/%E6%88%91%E6%89%80%E4%B8%8D%E8%83%BD%E6%89%BF%E5%8F%97%E7%9A%84%E7%94%9F%E5%91%BD%E4%B9%8B%E8%BD%BB/</url>
    <content><![CDATA[<p>我的408做的不算快，但也还算从容，离考试结束还有半小时时我便为答卷画上了句号。离考试结束还有五分钟的时候我便开始翘首以盼，等着收卷钟声的敲响。</p>
<p>那天的夕阳也是我这一年来见过的最美的夕阳，因为当你还在为焦虑、为失眠、为前程忧虑时你是永远无法感受到所谓的美好的。我要在考完初试之后好好体验一下我Steam中积压的库存、我要去紫金山看日出、我要在复试结束后去学吉他、我要……</p>
<p>当我从考场回到宾馆，我毫不犹豫的先下了那款观望已久的文明6。打开之后本以为是打打杀杀，但是当复杂的规则摆在我面前时我完全放弃了钻研的兴趣。我刚刚考完试我是来放松的不是来学规则的，接着入坑了原神和空洞骑士。原神确实是真的好玩，虽然在之前从来没有真正的玩过，但是“原神，启动”已经是算不上是家喻户晓但是至少也是妇孺皆知。空洞骑士也真很上头，除了跑图跑的是真的累，死亡扣金币扣的也是真的烦。</p>
<p>接下来的几天虽然也干了点正事，去上了两节课，写了两篇报告，也试着去读两本书。只是报告太少、GPA不再重要、GPT又太重要，以我一贯雷厉飞行的做事风格这点 assignment 并不足挂齿；我也学了点vue，把我的毕设的前端部分完成了一点；我也尝试着去为复试做一点准备，在力扣、AcWing上做点题目。但是空下来的时间还是太多，比起以前遇事不决来套卷子、还有时间要背单词的生活，我突然不知道怎么去安排这些时间，于是变成了遇事不决空洞骑士、还有时间开把原神。</p>
<p>暑假时我每天早上醒来的第一件事就是打开墨墨刷上几百个单词，现在每天早上醒来的第一件事是打开原神继续跑图。一个月前如果我突然感觉疲惫，我会去喝一杯水然后回来接着和408、数学做搏斗，现在当我打开空洞骑士一眨眼一个小时就悄悄溜走。</p>
<p>这样的生活我刚开始玩的真的很开心，但是很快我发现<strong>能这样一直游戏人生其实也是需要天赋的</strong>。而我，无论在什么方面都向来平庸，没有干正事的天赋其实也没有什么过花天酒地的生活的天赋。当我这样过到第三天，我就开始感觉游戏带给我的似乎不是快乐，而是<strong>空虚</strong>。去年寒假在家备考的时候偶尔背着自己的良心浪费了二十分钟在神将世界里，我神清气爽；现在我只是机械的打开软件，机械的控制着人物的前进，我真的想打开原神吗？我真的想打开空洞骑士吗？我只是打开了，我只是向前跳、向后跳、放大招，我不知道是我在玩游戏还是游戏在玩我。</p>
<p>于是在考完的第六天，我知道我不能再继续这样的生活了。我再次踏上了开往市区的地铁，当一次，还是上学期。我去了我想去了很久的地方，去了南京李先生的1701，去他的琴行里摸了摸我买不起的琴，坐在1701咖啡馆看着对面排练的乐队，那天没有演出，没有民谣也没有摇滚。但是半个楚翘城都贴着1701的logo，看来他真的过很好，不知道他还写不写歌了，不知道他还愤不愤怒了，不知道他是否已经知道这个世界会不会好？我又从雨花的1701跑到了下关的热河路。纪念碑旁那家开了很久的电影院早已不知所踪，就连纪念碑也被包围在地铁施工竖起来的围栏之中。我看到32路穿过了挹江门，但是当我想用相机抓拍这一刻时，32路早已消失在夜色。我又去拍了热河路的路牌，我去寻找路边的梧桐树上还有没有歌迷对于这个世界的问候，但是梧桐树上只有零碎的白漆盖掉了不只是谁写下的什么。</p>
<p>这天我跑的很累，横穿了半个南京。那天我一点钟才睡着，但是不到六点就醒来。听着室友的断断续续的鼾声，我突然开始理解了米兰·昆德拉所说的“不能承受的生命之轻”是什么。当我在焦虑今晚能不能睡得着、明早抢不抢的到图书馆我常坐的位置的时候，我如果没有闹钟可以轻轻松松睡到9点；当我每天逼着自己保证12个小时的学习时间的时候，比起做题我甚至都觉得力扣有点好玩，去浏览Steam最近又有什么折扣简直是享受；当我每天都要在图书馆从早做到晚的时候，觉得去市里遛弯是难得的奢侈，去操场上跑步也成了生活的糖果。但是当这一切真的结束了，当我真的可以从早玩到晚时，我却玩的不痛快、当我真的可以每天睡到9点再起床了我却睡不着了。</p>
<p>生命需要重量，但是我似乎总在超重和失重之间反复横跳。今天是2023年的最后一天，不到六点苏醒的我像前几天一样在早上醒来时打开了原神，我像前几天一样跑图、打怪，当我在副本中不幸被困之后我选择了退出，卸载应用。我要在今夜去登山，去迎接2024年的第一次日出。我想起疫情时被反复提及的那句话“没有一个冬天不可逾越，没有一个春天不会到来”，今早恰好看到我的一个同学也用这句话为自己的2023做了总结。我想我也许还在人生的冬季，也许冬天又还没有真的到来。但从明天起我要想去寻求不可承受的生命之重和不可承受的生命的受力平衡点。</p>
]]></content>
  </entry>
  <entry>
    <title>我们应该面向谁歌唱</title>
    <url>/2024/01/22/%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E9%9D%A2%E5%90%91%E8%B0%81%E6%AD%8C%E5%94%B1/</url>
    <content><![CDATA[<h2 style="text-align = right ">——腰乐队</h2>
![相见恨晚](/image/相见恨晚.jpeg)

]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>摇滚</tag>
      </tags>
  </entry>
  <entry>
    <title>关于南京我想的全是你</title>
    <url>/2024/06/29/%E5%85%B3%E4%BA%8E%E5%8D%97%E4%BA%AC%E6%88%91%E6%83%B3%E7%9A%84%E5%85%A8%E6%98%AF%E4%BD%A0/</url>
    <content><![CDATA[<h1 id="关于南京我想的全是你"><a href="#关于南京我想的全是你" class="headerlink" title="关于南京我想的全是你"></a>关于南京我想的全是你</h1><p>我曾听说过一个说法，说一个人14岁时听的音乐风格很大程度上决定了一个人后半生会会喜欢什么样的音乐。回想一下我的十四岁，似乎很幸运，那个时候我父母还没在电子产品的管束上对我放松分毫，所以14岁的我基本不听音乐，如果那个时候我也能每天揣着mp3很难想象我是不是至今依然陶醉于如小苹果之类的神曲之中。本来我就觉得我是个彻彻底底的屌丝，或者用我的某位朋友常用来形容他自己的那个词，“国男”，没错，似乎用来形容我更合适一点，毕竟我还是很有自知之明的觉得他其实比我小帅一点，如果我今日依然每天哼着“热爱一百零五度的你”，我觉得即使不用在自己的履历上加上某所大学的名字我便已经足够诠释“没有性张力”到底是什么。</p>
<p>还好还好，还好因为我14岁乃至18岁前在音乐方面的匮乏，让我在上了大学开始每天戴着耳机独来独往时我可以欣赏不同的音乐风格，虽然口水歌也不是没听过，但是总归还是能找到了条螺旋曲折且通往所谓的高雅的道路，导致我偶尔也会有突然的自信，是否我整天“仰天大笑出门去，我辈岂是蓬蒿人”的同时我还能标榜一下自己其实还是有一点，哪怕真的只是一点所谓的文青气质，没准还能吸引到谁？</p>
<p>于是我在大一的时候沉溺于流行乐，或者准确的说主要是沉溺于周杰伦，我觉得这除了和我高中时身边杰伦的铁粉扎堆之外还有一层原因是我大学宿舍的柜子上贴了张他的卡片，那断然不可能是我贴的，大概是四年前或者久远一点，八年前睡在那张我睡了四年的小床上的人贴上去的，可能是被夺舍了，但我觉得更可能是那段时间真的是被某个人灵魂附体，我那段时间发自内心的觉得杰伦就是最牛逼的。我听了他的每一张专辑、每一首歌，《稻香》在那一年被我循环了二百多遍，有很长一段时间，当我坐到图书馆的桌子前却没办法平心静气看书的时候，一首稻香总是能带我回到最初的美好，让我悸动的心慢慢平静。</p>
<p>我想我可能会一直做杰伦的铁粉，如果不是我在大二开学不久听到了罗大佑的《恋曲1980》，“你曾经对我说，你永远爱着我，爱情这东西我明白但永远是什么？”、“今天你欢乐将是明天将是明天永恒的回忆”，这包含对于爱情的思考的歌词和某些旋律动听的情歌相比之下，我承认我移情别恋了，我开始喜欢上这位华语乐坛教父级的人物。除了那些深刻而不失优美的情歌，我觉得罗大佑让我想起了高中时学到过的四个字——“文以载道”，同样，歌曲不应该只是用来寄托自己的儿女情长，不应该只是来写男女之事，不应该只是用来歌颂，不应该只是用来赞美，还能用来思考社会的发展，“台北不是我的家，我的家乡没有霓虹灯”；还能用来讽刺，“大厦关了一些样品屋，屋子加上铁窗防老鼠”；还能用来表达对和平的向往，“抬头寻找天空翅膀，候鸟出现他的影迹，带来远处的饥荒无情的战火依然存在的消息”，更不用提他那几首薛定谔的存在的，饱含了对时代变革思考的歌曲。如果说杰伦的歌激励我按下单曲循环的是他天才般的旋律创作，那么罗大佑的歌则更多是因为他的歌词。也因此，我开始真正的接触到了民谣和摇滚。</p>
<p>正如我一直坚信的，这个世界总是会让相似的灵魂相遇，无论以什么方式。具体的时间我可能已经模糊，但是我永远记得那是特殊时期被迫在宿舍足不出户的时光里，B站某段作为视频Bgm的轻音乐像闪电一样击中了我，弹幕上飘过“你离开了南京，从此没人和我说话”。那天晚上，我认识了那个叫陈小二的虚拟人物，尽管是个虚拟人物，但陈小二先生仿佛遥远星球上一个优秀百倍的我。无论是他拧巴的行事准则，又或者是作为一个理想主义者对于自己价值准则的的坚守，还有他对待生活和事情的认真，让我景仰，更是深刻的影响了我余下的大学生涯。30年前，陈小二先生因为罗大佑的歌曲抱起了吉他，30年后，因为他那些粗糙的歌谣，五音不全、对乐器一窍不通的我也第一次动了学一学乐器的心思，买了一把廉价的烧火棍，这样在未来的某个日子里，至少在我自怜自艾的时候我还能为自己再唱起那些歌曲，问一问理想究竟多少钱一斤，想一想这个世界是否会好。在刚刚过去的那个冬天，我也将要离开南京，我又去了热河路，冬天总是天黑的很早，五点多便已是华灯初上，那条路就像我老家小县城城区的那几条商业街一样，车来车往，路人行色匆匆，偶尔有两个忧郁青年会在路牌下停留，跟路牌凹一个能发社交媒体的造型，我可以想象他们的耳机里听的是什么，在那天晚上是不是会在朋友圈里多抄上几句歌词，无病呻吟一番，也许多年以前我也会，只是现在我不会。我去看32路穿过挹江门，但是它却不给我记录的机会，在我放下相机的时候匆匆驶来，又在我端着相机守候的时候姗姗来迟；我想去看纪念碑，但是施工队架起的围栏阻挡了我的视野；我走过了盐仓桥、走过了南京火车西站，却没有寻觅到秋林龙虾现在开在了哪里；我看到了也有情侣手牵手走过，谁说没有人在热河路谈恋爱？我在直线和曲线之间迷路，我气喘吁吁，我问自己如果没有来过这里，如果没有走过那些路，现在的我是否会过的很幸福？我不知道。</p>
<p>春天我去了楚翘城，去了他开的琴行，只是他的琴太贵，我拨了拨琴弦装作对吉他的音色很有研究似的点了点头又摇了摇头，不敢多看标价一眼就走出了商铺。也许我对他对喜欢远没有我想象的那么奢侈，至少不值一把几万的吉他，如果给个合理的标价，也许是一杯比星巴克还贵了一点的咖啡。我走进了Livehouse楼下那间雅致的咖啡馆，在那里我能找到桌子上有野外合作社、PK14的专辑却没能找到陈小二的，我坐下来，端起咖啡，咖啡馆尽头的大落地窗下依然在排练的乐队奏出并不完美的曲调，可我的耳朵里全是so me re me re do…</p>
]]></content>
  </entry>
</search>
